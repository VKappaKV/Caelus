#pragma version 11
intcblock 0 1 8 6 4 100000 10 1000 4096 2 3 320 330 28500 50000 15 32
bytecblock 0x 0x746f74616c7374616b65 0x63697263756c6174696e67537570706c79 0x69646c65416c676f 0x6275726e5072696f 0x00 0x6275726e5175657565 0x666c6173684c6f616e436f756e746572 0x76414c474f6964 0x76616c696461746f72417070726f76616c50726f6772616d 0x76616c696461746f72506f6f6c56657273696f6e 0x68696768657374426964646572 0x3dc7ae79 0x73617475726174696f6e427566666572 0x151f7c75 0x7665737469676541646472657373 0x6275726e436f6f6c646f776e 0x706567 0x696e6974506f6f6c436f6e7472616374 0x697344656c696e7175656e74 0x6275726e45786861757374 0x696e69745f76414c474f 0x6d616e61676572 0x6f72646572 0xb4bfca50 0xdcae771b 0x6c617374466c6173686c6f616e426c6f636b 0x6f70657261746f7241646472657373 0x64656c6567617465645374616b65 0x64656c6567617465645354616b65 0x6f70657261746f72436f6d6d6974 0x7374566573744944 0x766573744944

// This TEAL was generated by TEALScript v0.105.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\CaelusAdmin.algo.ts:92
	// this.totalAlgoStaked.value = 0
	bytec 1 //  "totalstake"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:93
	// this.init_vALGO.value = false
	bytec 21 //  "init_vALGO"
	intc 0 // 0
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusAdmin.algo.ts:94
	// this.initializedPoolContract.value = false
	bytec 18 //  "initPoolContract"
	intc 0 // 0
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusAdmin.algo.ts:95
	// this.validatorPoolContractVersion.value = 0
	bytec 10 //  "validatorPoolVersion"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:96
	// this.pegRatio.value = 1 * SCALE
	bytec 17 //  "peg"
	intc 5 // 100000
	app_global_put

	// contracts\CaelusAdmin.algo.ts:97
	// this.circulatingSupply.value = 0
	bytec 2 //  "circulatingSupply"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:98
	// this.idleAlgoToStake.value = 0
	bytec 3 //  "idleAlgo"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:99
	// this.flashLoanCounter.value = 0
	bytec 7 //  "flashLoanCounter"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:100
	// this.vestigeAddress.value = this.app.creator
	bytec 15 //  "vestigeAddress"
	txna Applications 0
	app_params_get AppCreator
	pop
	app_global_put

	// contracts\CaelusAdmin.algo.ts:101
	// this.manager.value = this.app.creator
	bytec 22 //  "manager"
	txna Applications 0
	app_params_get AppCreator
	pop
	app_global_put

	// contracts\CaelusAdmin.algo.ts:102
	// this.initBurnQueue()
	callsub initBurnQueue

	// contracts\CaelusAdmin.algo.ts:103
	// this.highestBidder.value = AppID.fromUint64(0)
	bytec 11 //  "highestBidder"
	intc 0 // 0
	app_global_put
	retsub

// creatorChangeCreatorRelatedParams(address,uint64,uint64)void
*abi_route_creatorChangeCreatorRelatedParams:
	// stVestID: uint64
	txna ApplicationArgs 3
	btoi

	// vestID: uint64
	txna ApplicationArgs 2
	btoi

	// newVestigeAddress: address
	txna ApplicationArgs 1
	dup
	len
	intc 16 // 32
	==

	// argument 2 (newVestigeAddress) for creatorChangeCreatorRelatedParams must be a address
	assert

	// execute creatorChangeCreatorRelatedParams(address,uint64,uint64)void
	callsub creatorChangeCreatorRelatedParams
	intc 1 // 1
	return

// creatorChangeCreatorRelatedParams(newVestigeAddress: Address, vestID: AssetID, stVestID: AssetID): void
creatorChangeCreatorRelatedParams:
	proto 3 0

	// contracts\CaelusAdmin.algo.ts:107
	// assert(this.txn.sender === this.app.creator || this.txn.sender === this.vestigeAddress.value)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	dup
	bnz *skip_or0
	txn Sender
	bytec 15 //  "vestigeAddress"
	app_global_get
	==
	||

*skip_or0:
	assert

	// contracts\CaelusAdmin.algo.ts:108
	// this.vestigeAddress.value = newVestigeAddress
	bytec 15 //  "vestigeAddress"
	frame_dig -1 // newVestigeAddress: Address
	app_global_put

	// contracts\CaelusAdmin.algo.ts:109
	// this.vestID.value = vestID
	bytec 32 //  "vestID"
	frame_dig -2 // vestID: AssetID
	app_global_put

	// contracts\CaelusAdmin.algo.ts:110
	// this.stVestID.value = stVestID
	bytec 31 //  "stVestID"
	frame_dig -3 // stVestID: AssetID
	app_global_put
	retsub

// initPoolContract(uint64)void
*abi_route_initPoolContract:
	// programSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute initPoolContract(uint64)void
	callsub initPoolContract
	intc 1 // 1
	return

// initPoolContract(programSize: uint64): void
initPoolContract:
	proto 1 0

	// contracts\CaelusAdmin.algo.ts:114
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts\CaelusAdmin.algo.ts:115
	// assert(!this.initializedPoolContract.value, 'can only be initialized once')
	bytec 18 //  "initPoolContract"
	app_global_get
	intc 0 // 0
	getbit
	!

	// can only be initialized once
	assert

	// contracts\CaelusAdmin.algo.ts:116
	// this.validatorPoolContractApprovalProgram.create(programSize)
	bytec 9 //  "validatorApprovalProgram"
	frame_dig -1 // programSize: uint64
	box_create
	pop

	// contracts\CaelusAdmin.algo.ts:117
	// this.initializedPoolContract.value = true
	bytec 18 //  "initPoolContract"
	intc 1 // 1
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusAdmin.algo.ts:118
	// this.validatorPoolContractVersion.value += 1
	bytec 10 //  "validatorPoolVersion"
	app_global_get
	intc 1 // 1
	+
	bytec 10 //  "validatorPoolVersion"
	swap
	app_global_put
	retsub

// writePoolContractProgram(uint64,byte[])void
*abi_route_writePoolContractProgram:
	// data: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// offset: uint64
	txna ApplicationArgs 1
	btoi

	// execute writePoolContractProgram(uint64,byte[])void
	callsub writePoolContractProgram
	intc 1 // 1
	return

// writePoolContractProgram(offset: uint64, data: bytes): void
writePoolContractProgram:
	proto 2 0

	// contracts\CaelusAdmin.algo.ts:122
	// assert(this.txn.sender === this.manager.value)
	txn Sender
	bytec 22 //  "manager"
	app_global_get
	==
	assert

	// contracts\CaelusAdmin.algo.ts:123
	// this.validatorPoolContractApprovalProgram.replace(offset, data)
	bytec 9 //  "validatorApprovalProgram"
	frame_dig -1 // offset: uint64
	frame_dig -2 // data: bytes
	box_replace
	retsub

// updatePoolContract(uint64)void
*abi_route_updatePoolContract:
	// programSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute updatePoolContract(uint64)void
	callsub updatePoolContract
	intc 1 // 1
	return

// updatePoolContract(programSize: uint64): void
updatePoolContract:
	proto 1 0

	// contracts\CaelusAdmin.algo.ts:127
	// assert(this.txn.sender === this.manager.value)
	txn Sender
	bytec 22 //  "manager"
	app_global_get
	==
	assert

	// *if0_condition
	// contracts\CaelusAdmin.algo.ts:128
	// this.validatorPoolContractApprovalProgram.size < programSize
	bytec 9 //  "validatorApprovalProgram"
	box_len

	// box value does not exist: this.validatorPoolContractApprovalProgram.size
	assert
	frame_dig -1 // programSize: uint64
	<
	bz *if0_end

	// *if0_consequent
	// contracts\CaelusAdmin.algo.ts:129
	// this.validatorPoolContractApprovalProgram.resize(programSize)
	bytec 9 //  "validatorApprovalProgram"
	frame_dig -1 // programSize: uint64
	box_resize

*if0_end:
	// contracts\CaelusAdmin.algo.ts:131
	// this.validatorPoolContractVersion.value += 1
	bytec 10 //  "validatorPoolVersion"
	app_global_get
	intc 1 // 1
	+
	bytec 10 //  "validatorPoolVersion"
	swap
	app_global_put
	retsub

// initLST(string,string,string)void
*abi_route_initLST:
	// url: string
	txna ApplicationArgs 3
	extract 2 0

	// unitName: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute initLST(string,string,string)void
	callsub initLST
	intc 1 // 1
	return

// initLST(name: string, unitName: string, url: string): void
initLST:
	proto 3 0

	// contracts\CaelusAdmin.algo.ts:135
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts\CaelusAdmin.algo.ts:136
	// assert(!this.init_vALGO.value)
	bytec 21 //  "init_vALGO"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// contracts\CaelusAdmin.algo.ts:137
	// this.vALGOid.value = sendAssetCreation({
	//       configAssetTotal: 10_000_000,
	//       configAssetDecimals: 6,
	//       configAssetReserve: this.app.address,
	//       configAssetManager: globals.zeroAddress,
	//       configAssetClawback: globals.zeroAddress,
	//       configAssetFreeze: globals.zeroAddress,
	//       configAssetDefaultFrozen: 0,
	//       configAssetName: name,
	//       configAssetUnitName: unitName,
	//       configAssetURL: url,
	//     })
	bytec 8 //  "vALGOid"
	itxn_begin
	intc 10 //  acfg
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:138
	// configAssetTotal: 10_000_000
	pushint 10_000_000
	itxn_field ConfigAssetTotal

	// contracts\CaelusAdmin.algo.ts:139
	// configAssetDecimals: 6
	intc 3 // 6
	itxn_field ConfigAssetDecimals

	// contracts\CaelusAdmin.algo.ts:140
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// contracts\CaelusAdmin.algo.ts:141
	// configAssetManager: globals.zeroAddress
	global ZeroAddress
	itxn_field ConfigAssetManager

	// contracts\CaelusAdmin.algo.ts:142
	// configAssetClawback: globals.zeroAddress
	global ZeroAddress
	itxn_field ConfigAssetClawback

	// contracts\CaelusAdmin.algo.ts:143
	// configAssetFreeze: globals.zeroAddress
	global ZeroAddress
	itxn_field ConfigAssetFreeze

	// contracts\CaelusAdmin.algo.ts:144
	// configAssetDefaultFrozen: 0
	intc 0 // 0
	itxn_field ConfigAssetDefaultFrozen

	// contracts\CaelusAdmin.algo.ts:145
	// configAssetName: name
	frame_dig -1 // name: string
	itxn_field ConfigAssetName

	// contracts\CaelusAdmin.algo.ts:146
	// configAssetUnitName: unitName
	frame_dig -2 // unitName: string
	itxn_field ConfigAssetUnitName

	// contracts\CaelusAdmin.algo.ts:147
	// configAssetURL: url
	frame_dig -3 // url: string
	itxn_field ConfigAssetURL

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	app_global_put

	// contracts\CaelusAdmin.algo.ts:149
	// this.init_vALGO.value = true
	bytec 21 //  "init_vALGO"
	intc 1 // 1
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// initBurnQueue()void
*abi_route_initBurnQueue:
	// execute initBurnQueue()void
	callsub initBurnQueue
	intc 1 // 1
	return

// initBurnQueue(): void
initBurnQueue:
	proto 0 0

	// contracts\CaelusAdmin.algo.ts:153
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// *if1_condition
	// contracts\CaelusAdmin.algo.ts:154
	// !this.burnQueue.exists
	bytec 6 //  "burnQueue"
	box_len
	swap
	pop
	!
	bz *if1_end

	// *if1_consequent
	// contracts\CaelusAdmin.algo.ts:155
	// this.burnQueue.value = [AppID.fromUint64(0)]
	bytec 6 //  "burnQueue"
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	box_put

*if1_end:
	// *if2_condition
	// contracts\CaelusAdmin.algo.ts:157
	// !this.burnPrio.exists
	txna Applications 0
	bytec 4 //  "burnPrio"
	app_global_get_ex
	swap
	pop
	!
	bz *if2_end

	// *if2_consequent
	// contracts\CaelusAdmin.algo.ts:158
	// this.burnPrio.value = AppID.fromUint64(0)
	bytec 4 //  "burnPrio"
	intc 0 // 0
	app_global_put

*if2_end:
	retsub

// addCaelusValidator(pay)void
*abi_route_addCaelusValidator:
	// mbrPay: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (mbrPay) for addCaelusValidator must be a pay transaction
	assert

	// execute addCaelusValidator(pay)void
	callsub addCaelusValidator
	intc 1 // 1
	return

// addCaelusValidator(mbrPay: PayTxn): void
addCaelusValidator:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusAdmin.algo.ts:163
	// mbr = this.minBalanceForAccount(
	//       1,
	//       3,
	//       1,
	//       0,
	//       0,
	//       CaelusValidatorPool.schema.global.numUint,
	//       CaelusValidatorPool.schema.global.numByteSlice
	//     )
	intc 4 // 4
	intc 15 // 15
	intc 0 // 0
	dup
	intc 1 // 1
	intc 10 // 3
	intc 1 // 1
	callsub minBalanceForAccount
	frame_bury 0 // mbr: uint64

	// contracts\CaelusAdmin.algo.ts:172
	// verifyPayTxn(mbrPay, {
	//       receiver: this.app.address,
	//       amount: mbr,
	//     })
	// verify receiver
	frame_dig -1 // mbrPay: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPay","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPay: PayTxn
	gtxns Amount
	frame_dig 0 // mbr: uint64
	==

	// transaction verification failed: {"txn":"mbrPay","field":"amount","expected":"mbr"}
	assert

	// contracts\CaelusAdmin.algo.ts:177
	// sendAppCall({
	//       onCompletion: OnCompletion.NoOp,
	//       approvalProgram: [
	//         this.validatorPoolContractApprovalProgram.extract(0, 4096),
	//         this.validatorPoolContractApprovalProgram.extract(4096, this.validatorPoolContractApprovalProgram.size - 4096),
	//       ],
	//       clearStateProgram: CaelusValidatorPool.clearProgram(),
	//       globalNumUint: CaelusValidatorPool.schema.global.numUint,
	//       globalNumByteSlice: CaelusValidatorPool.schema.global.numByteSlice,
	//       extraProgramPages: 3,
	//       applicationArgs: [
	//         method('createApplication(uint64,bytes,uint64,uint64,uint64,uint64)void'),
	//         itob(this.app.id),
	//         this.txn.sender,
	//         itob(this.validatorPoolContractVersion.value),
	//         itob(this.vestID.value),
	//         itob(this.stVestID.value),
	//         itob(this.vALGOid.value),
	//       ],
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:178
	// onCompletion: OnCompletion.NoOp
	intc 0 //  NoOp
	itxn_field OnCompletion

	// contracts\CaelusAdmin.algo.ts:179
	// approvalProgram: [
	//         this.validatorPoolContractApprovalProgram.extract(0, 4096),
	//         this.validatorPoolContractApprovalProgram.extract(4096, this.validatorPoolContractApprovalProgram.size - 4096),
	//       ]
	bytec 9 //  "validatorApprovalProgram"
	intc 0 // 0
	intc 8 // 4096
	box_extract
	itxn_field ApprovalProgramPages
	bytec 9 //  "validatorApprovalProgram"
	intc 8 // 4096
	bytec 9 //  "validatorApprovalProgram"
	box_len

	// box value does not exist: this.validatorPoolContractApprovalProgram.size
	assert
	intc 8 // 4096
	-
	box_extract
	itxn_field ApprovalProgramPages

	// contracts\CaelusAdmin.algo.ts:183
	// clearStateProgram: CaelusValidatorPool.clearProgram()
	pushbytes 0x0b
	itxn_field ClearStateProgram

	// contracts\CaelusAdmin.algo.ts:184
	// globalNumUint: CaelusValidatorPool.schema.global.numUint
	intc 15 // 15
	itxn_field GlobalNumUint

	// contracts\CaelusAdmin.algo.ts:185
	// globalNumByteSlice: CaelusValidatorPool.schema.global.numByteSlice
	intc 4 // 4
	itxn_field GlobalNumByteSlice

	// contracts\CaelusAdmin.algo.ts:186
	// extraProgramPages: 3
	intc 10 // 3
	itxn_field ExtraProgramPages

	// contracts\CaelusAdmin.algo.ts:187
	// applicationArgs: [
	//         method('createApplication(uint64,bytes,uint64,uint64,uint64,uint64)void'),
	//         itob(this.app.id),
	//         this.txn.sender,
	//         itob(this.validatorPoolContractVersion.value),
	//         itob(this.vestID.value),
	//         itob(this.stVestID.value),
	//         itob(this.vALGOid.value),
	//       ]
	pushbytes 0x7869c387 // method "createApplication(uint64,bytes,uint64,uint64,uint64,uint64)void"
	itxn_field ApplicationArgs
	txna Applications 0
	itob
	itxn_field ApplicationArgs
	txn Sender
	itxn_field ApplicationArgs
	bytec 10 //  "validatorPoolVersion"
	app_global_get
	itob
	itxn_field ApplicationArgs
	bytec 32 //  "vestID"
	app_global_get
	itob
	itxn_field ApplicationArgs
	bytec 31 //  "stVestID"
	app_global_get
	itob
	itxn_field ApplicationArgs
	bytec 8 //  "vALGOid"
	app_global_get
	itob
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:196
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:199
	// this.validatorAddedEvent.log({
	//       operator: this.txn.sender,
	//       version: this.validatorPoolContractVersion.value,
	//     })
	pushbytes 0x57eb6699 // validatorAddedEvent(address,uint64)
	txn Sender
	bytec 10 //  "validatorPoolVersion"
	app_global_get
	itob
	concat
	concat
	log
	retsub

// calculateLSTRatio()void
*abi_route_calculateLSTRatio:
	// execute calculateLSTRatio()void
	callsub calculateLSTRatio
	intc 1 // 1
	return

// calculateLSTRatio(): void
calculateLSTRatio:
	proto 0 0

	// contracts\CaelusAdmin.algo.ts:207
	// this.pegRatio.value = wideRatio([this.totalAlgoStaked.value, SCALE], [this.circulatingSupply.value])
	bytec 17 //  "peg"
	bytec 1 //  "totalstake"
	app_global_get
	intc 5 // 100000
	mulw
	intc 0 // 0
	bytec 2 //  "circulatingSupply"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	app_global_put
	retsub

// getMintAmount(uint64)uint64
*abi_route_getMintAmount:
	// The ABI return prefix
	bytec 14 // 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute getMintAmount(uint64)uint64
	callsub getMintAmount
	itob
	concat
	log
	intc 1 // 1
	return

// getMintAmount(amount: uint64): uint64
getMintAmount:
	proto 1 1

	// contracts\CaelusAdmin.algo.ts:211
	// this.calculateLSTRatio()
	callsub calculateLSTRatio

	// contracts\CaelusAdmin.algo.ts:212
	// return wideRatio([amount, SCALE], [this.pegRatio.value]);
	frame_dig -1 // amount: uint64
	intc 5 // 100000
	mulw
	intc 0 // 0
	bytec 17 //  "peg"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// getBurnAmount(uint64)uint64
*abi_route_getBurnAmount:
	// The ABI return prefix
	bytec 14 // 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBurnAmount(uint64)uint64
	callsub getBurnAmount
	itob
	concat
	log
	intc 1 // 1
	return

// getBurnAmount(amount: uint64): uint64
getBurnAmount:
	proto 1 1

	// contracts\CaelusAdmin.algo.ts:216
	// this.calculateLSTRatio()
	callsub calculateLSTRatio

	// contracts\CaelusAdmin.algo.ts:217
	// return wideRatio([amount, this.pegRatio.value], [SCALE]);
	frame_dig -1 // amount: uint64
	bytec 17 //  "peg"
	app_global_get
	mulw
	intc 0 // 0
	intc 5 // 100000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	retsub

// delayedMintRequest(pay)void
*abi_route_delayedMintRequest:
	// mintTxn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (mintTxn) for delayedMintRequest must be a pay transaction
	assert

	// execute delayedMintRequest(pay)void
	callsub delayedMintRequest
	intc 1 // 1
	return

// delayedMintRequest(mintTxn: PayTxn): void
delayedMintRequest:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:221
	// assert(mintTxn.amount >= ALGORAND_BASE_FEE, 'minimum amount to stake is 0.001 Algo')
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	intc 7 // 1000
	>=

	// minimum amount to stake is 0.001 Algo
	assert

	// contracts\CaelusAdmin.algo.ts:222
	// verifyPayTxn(mintTxn, {
	//       receiver: this.app.address,
	//     })
	// verify receiver
	frame_dig -1 // mintTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mintTxn","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:225
	// this.idleAlgoToStake.value += mintTxn.amount
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:226
	// minted = this.getMintAmount(mintTxn.amount)
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	callsub getMintAmount
	frame_bury 0 // minted: uint64

	// contracts\CaelusAdmin.algo.ts:228
	// mintOrder: MintClaim = {
	//       amount: minted,
	//       block: globals.round,
	//     }
	global Round
	itob
	frame_dig 0 // minted: uint64
	itob
	concat
	frame_bury 1 // mintOrder: MintClaim

	// contracts\CaelusAdmin.algo.ts:233
	// this.mintOrders(mintTxn.sender).value = mintOrder
	bytec 23 //  "order"
	frame_dig -1 // mintTxn: PayTxn
	gtxns Sender
	concat
	frame_dig 1 // mintOrder: MintClaim
	box_put

	// contracts\CaelusAdmin.algo.ts:234
	// this.totalAlgoStaked.value += mintTxn.amount
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	+
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:236
	// this.mintEvent.log({
	//       instant: false,
	//       amount: mintTxn.amount,
	//       output: minted,
	//     })
	bytec 24 //  mintEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	dup
	setbit
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig 0 // minted: uint64
	itob
	concat
	concat
	log
	retsub

// claimMint()void
*abi_route_claimMint:
	// execute claimMint()void
	callsub claimMint
	intc 1 // 1
	return

// claimMint(): void
claimMint:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusAdmin.algo.ts:244
	// assert(
	//       this.mintOrders(this.txn.sender).value.block < globals.round - CLAIM_DELAY,
	//       'must wait 330 blocks after initial mint to claim the token'
	//     )
	intc 0 // 0
	intc 2 // 8
	bytec 23 //  "order"
	txn Sender
	concat
	cover 2
	box_extract
	btoi
	global Round
	intc 12 // 330
	-
	<

	// must wait 330 blocks after initial mint to claim the token
	assert

	// contracts\CaelusAdmin.algo.ts:248
	// minted = this.mintOrders(this.txn.sender).value.amount
	intc 2 //  headOffset
	intc 2 // 8
	bytec 23 //  "order"
	txn Sender
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // minted: uint64

	// contracts\CaelusAdmin.algo.ts:249
	// sendAssetTransfer({
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: minted,
	//       fee: 0,
	//     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:250
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:251
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:252
	// assetAmount: minted
	frame_dig 0 // minted: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:253
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:255
	// this.circulatingSupply.value += minted
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig 0 // minted: uint64
	+
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put
	retsub

// instantMintRequest(pay)void
*abi_route_instantMintRequest:
	// mintTxn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (mintTxn) for instantMintRequest must be a pay transaction
	assert

	// execute instantMintRequest(pay)void
	callsub instantMintRequest
	intc 1 // 1
	return

// instantMintRequest(mintTxn: PayTxn): void
instantMintRequest:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:259
	// assert(mintTxn.amount >= ALGORAND_BASE_FEE, 'minimum amount to stake is 0.001 Algo')
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	intc 7 // 1000
	>=

	// minimum amount to stake is 0.001 Algo
	assert

	// contracts\CaelusAdmin.algo.ts:260
	// verifyPayTxn(mintTxn, {
	//       receiver: this.app.address,
	//     })
	// verify receiver
	frame_dig -1 // mintTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mintTxn","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:263
	// premium = this.getPremiumAmount(mintTxn.amount)
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	callsub getPremiumAmount
	frame_bury 0 // premium: uint64

	// contracts\CaelusAdmin.algo.ts:264
	// minted = this.getMintAmount(mintTxn.amount - premium)
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	frame_dig 0 // premium: uint64
	-
	callsub getMintAmount
	frame_bury 1 // minted: uint64

	// contracts\CaelusAdmin.algo.ts:265
	// sendAssetTransfer({
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: this.txn.sender,
	//       assetAmount: minted,
	//       fee: 0,
	//     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:266
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:267
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:268
	// assetAmount: minted
	frame_dig 1 // minted: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:269
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:271
	// this.idleAlgoToStake.value += mintTxn.amount
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:272
	// this.circulatingSupply.value += minted
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig 1 // minted: uint64
	+
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:273
	// this.totalAlgoStaked.value += mintTxn.amount
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	+
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:275
	// this.mintEvent.log({
	//       instant: true,
	//       amount: mintTxn.amount,
	//       output: minted,
	//     })
	bytec 24 //  mintEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	intc 1 // 1
	setbit
	frame_dig -1 // mintTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig 1 // minted: uint64
	itob
	concat
	concat
	log
	retsub

// getPremiumAmount(uint64)uint64
*abi_route_getPremiumAmount:
	// The ABI return prefix
	bytec 14 // 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPremiumAmount(uint64)uint64
	callsub getPremiumAmount
	itob
	concat
	log
	intc 1 // 1
	return

// getPremiumAmount(amount: uint64): uint64
getPremiumAmount:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\CaelusAdmin.algo.ts:283
	// assert(this.txn.firstValid === globals.round - 330)
	txn FirstValid
	global Round
	intc 12 // 330
	-
	==
	assert

	// contracts\CaelusAdmin.algo.ts:284
	// lookupRound = globals.round - 2 - 320
	global Round
	intc 9 // 2
	-
	intc 11 // 320
	-
	frame_bury 0 // lookupRound: uint64

	// contracts\CaelusAdmin.algo.ts:285
	// accumulatedRewards = 0
	intc 0 // 0
	frame_bury 1 // accumulatedRewards: uint64

	// contracts\CaelusAdmin.algo.ts:286
	// for (let i = 0; i < 320; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts\CaelusAdmin.algo.ts:286
	// i < 320
	frame_dig 2 // i: uint64
	intc 11 // 320
	<
	bz *for_0_end

	// contracts\CaelusAdmin.algo.ts:287
	// accumulatedRewards += blocks[lookupRound].proposerPayout
	frame_dig 1 // accumulatedRewards: uint64
	frame_dig 0 // lookupRound: uint64
	block BlkProposerPayout
	+
	frame_bury 1 // accumulatedRewards: uint64

	// contracts\CaelusAdmin.algo.ts:288
	// lookupRound += 1
	frame_dig 0 // lookupRound: uint64
	intc 1 // 1
	+
	frame_bury 0 // lookupRound: uint64

*for_0_continue:
	// contracts\CaelusAdmin.algo.ts:286
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts\CaelusAdmin.algo.ts:290
	// return wideRatio([amount, accumulatedRewards], [this.totalAlgoStaked.value]);
	frame_dig -1 // amount: uint64
	frame_dig 1 // accumulatedRewards: uint64
	mulw
	intc 0 // 0
	bytec 1 //  "totalstake"
	app_global_get
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// burnRequest(axfer,address)void
*abi_route_burnRequest:
	// burnTo: address
	txna ApplicationArgs 1
	dup
	len
	intc 16 // 32
	==

	// argument 0 (burnTo) for burnRequest must be a address
	assert

	// burnTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (burnTxn) for burnRequest must be a axfer transaction
	assert

	// execute burnRequest(axfer,address)void
	callsub burnRequest
	intc 1 // 1
	return

// burnRequest(burnTxn: AssetTransferTxn, burnTo: Address): void
burnRequest:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 6

	// contracts\CaelusAdmin.algo.ts:294
	// assert(burnTxn.assetAmount >= ALGORAND_BASE_FEE)
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	intc 7 // 1000
	>=
	assert

	// contracts\CaelusAdmin.algo.ts:295
	// verifyAssetTransferTxn(burnTxn, {
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: this.app.address,
	//     })
	// verify xferAsset
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 8 //  "vALGOid"
	app_global_get
	==

	// transaction verification failed: {"txn":"burnTxn","field":"xferAsset","expected":"this.vALGOid.value"}
	assert

	// verify assetReceiver
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"burnTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// *if3_condition
	// contracts\CaelusAdmin.algo.ts:300
	// this.burnExhaust.value && !this.queueIsFull() && globals.round - this.burnCooldownFromBlock.value > 1
	bytec 20 //  "burnExhaust"
	app_global_get
	intc 0 // 0
	getbit
	dup
	bz *skip_and0
	callsub queueIsFull
	!
	&&

*skip_and0:
	dup
	bz *skip_and1
	global Round
	bytec 16 //  "burnCooldown"
	app_global_get
	-
	intc 1 // 1
	>
	&&

*skip_and1:
	bz *if3_end

	// *if3_consequent
	// contracts\CaelusAdmin.algo.ts:301
	// assert(
	//         globals.round - this.burnCooldownFromBlock.value > BURN_COOLDOW,
	//         'wait at least 10 blocks since Exhaust Block'
	//       )
	global Round
	bytec 16 //  "burnCooldown"
	app_global_get
	-
	intc 6 // 10
	>

	// wait at least 10 blocks since Exhaust Block
	assert

	// contracts\CaelusAdmin.algo.ts:305
	// this.burnExhaust.value = false
	bytec 20 //  "burnExhaust"
	intc 0 // 0
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

*if3_end:
	// contracts\CaelusAdmin.algo.ts:307
	// amtToBurn = this.getBurnAmount(burnTxn.assetAmount)
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	callsub getBurnAmount
	frame_bury 0 // amtToBurn: uint64

	// contracts\CaelusAdmin.algo.ts:308
	// burning = 0
	intc 0 // 0
	frame_bury 1 // burning: uint64

	// *if4_condition
	// contracts\CaelusAdmin.algo.ts:309
	// this.isPool(this.burnPrio.value)
	bytec 4 //  "burnPrio"
	app_global_get
	callsub isPool
	bz *if4_end

	// *if4_consequent
	// contracts\CaelusAdmin.algo.ts:310
	// dlgToPrio = this.burnPrio.value.globalState('delegatedStake') as uint64
	bytec 4 //  "burnPrio"
	app_global_get
	bytec 28 //  "delegatedStake"
	app_global_get_ex

	// global state value does not exist: this.burnPrio.value.globalState('delegatedStake')
	assert
	frame_bury 2 // dlgToPrio: uint64

	// *if5_condition
	// contracts\CaelusAdmin.algo.ts:311
	// dlgToPrio >= amtToBurn
	frame_dig 2 // dlgToPrio: uint64
	frame_dig 0 // amtToBurn: uint64
	>=
	bz *if5_end

	// *if5_consequent
	// contracts\CaelusAdmin.algo.ts:312
	// sendMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//           applicationID: this.burnPrio.value,
	//           methodArgs: [amtToBurn, burnTo],
	//           fee: 0,
	//         })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:313
	// applicationID: this.burnPrio.value
	bytec 4 //  "burnPrio"
	app_global_get
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:314
	// methodArgs: [amtToBurn, burnTo]
	frame_dig 0 // amtToBurn: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // burnTo: Address
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:315
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if6_condition
	// contracts\CaelusAdmin.algo.ts:317
	// this.isPool(this.burnQueue.value[0])
	bytec 6 //  "burnQueue"
	intc 0 // 0
	intc 2 // 8
	box_extract
	btoi
	callsub isPool
	bz *if6_end

	// *if6_consequent
	// contracts\CaelusAdmin.algo.ts:318
	// this.snitchToBurn(this.burnQueue.value[0])
	bytec 6 //  "burnQueue"
	intc 0 // 0
	intc 2 // 8
	box_extract
	btoi
	callsub snitchToBurn

*if6_end:
	// contracts\CaelusAdmin.algo.ts:320
	// return;
	retsub

*if5_end:
	// contracts\CaelusAdmin.algo.ts:322
	// burning = this.burnPrio.value.globalState('delegatedSTake') as uint64
	bytec 4 //  "burnPrio"
	app_global_get
	bytec 29 //  "delegatedSTake"
	app_global_get_ex

	// global state value does not exist: this.burnPrio.value.globalState('delegatedSTake')
	assert
	frame_bury 1 // burning: uint64

	// contracts\CaelusAdmin.algo.ts:323
	// this.pendingGroup.addMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//         applicationID: this.burnPrio.value,
	//         methodArgs: [dlgToPrio, burnTo],
	//         fee: 0,
	//       })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:324
	// applicationID: this.burnPrio.value
	bytec 4 //  "burnPrio"
	app_global_get
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:325
	// methodArgs: [dlgToPrio, burnTo]
	frame_dig 2 // dlgToPrio: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // burnTo: Address
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:326
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if4_end:
	// contracts\CaelusAdmin.algo.ts:329
	// for (let i = 0; i < this.burnQueue.value.length; i += 1)
	intc 0 // 0
	frame_bury 3 // i: uint64

*for_1:
	// contracts\CaelusAdmin.algo.ts:329
	// i < this.burnQueue.value.length
	frame_dig 3 // i: uint64
	intc 6 // 10
	<
	bz *for_1_end

	// contracts\CaelusAdmin.algo.ts:330
	// v = this.burnQueue.value[i]
	frame_dig 3 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	frame_bury 4 // v: uint64

	// *if7_condition
	// contracts\CaelusAdmin.algo.ts:331
	// this.isPool(v)
	frame_dig 4 // v: uint64
	callsub isPool
	bz *if7_end

	// *if7_consequent
	// contracts\CaelusAdmin.algo.ts:332
	// dlgToV = v.globalState('delegatedSTake') as uint64
	frame_dig 4 // v: uint64
	bytec 29 //  "delegatedSTake"
	app_global_get_ex

	// global state value does not exist: v.globalState('delegatedSTake')
	assert
	frame_bury 5 // dlgToV: uint64

	// *if8_condition
	// contracts\CaelusAdmin.algo.ts:333
	// dlgToV < amtToBurn - burning
	frame_dig 5 // dlgToV: uint64
	frame_dig 0 // amtToBurn: uint64
	frame_dig 1 // burning: uint64
	-
	<
	bz *if8_else

	// *if8_consequent
	// contracts\CaelusAdmin.algo.ts:334
	// this.pendingGroup.addMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//             applicationID: v,
	//             methodArgs: [dlgToV, burnTo],
	//             fee: 0,
	//           })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:335
	// applicationID: v
	frame_dig 4 // v: uint64
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:336
	// methodArgs: [dlgToV, burnTo]
	frame_dig 5 // dlgToV: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // burnTo: Address
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:337
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts\CaelusAdmin.algo.ts:339
	// burning += dlgToV
	frame_dig 1 // burning: uint64
	frame_dig 5 // dlgToV: uint64
	+
	frame_bury 1 // burning: uint64
	b *if8_end

*if8_else:
	// contracts\CaelusAdmin.algo.ts:341
	// this.pendingGroup.addMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//             applicationID: v,
	//             methodArgs: [amtToBurn - burning, burnTo],
	//             fee: 0,
	//           })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:342
	// applicationID: v
	frame_dig 4 // v: uint64
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:343
	// methodArgs: [amtToBurn - burning, burnTo]
	frame_dig 0 // amtToBurn: uint64
	frame_dig 1 // burning: uint64
	-
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // burnTo: Address
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:344
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts\CaelusAdmin.algo.ts:346
	// burning = amtToBurn
	frame_dig 0 // amtToBurn: uint64
	frame_bury 1 // burning: uint64
	b *for_1_end

*if8_end:

*if7_end:

*for_1_continue:
	// contracts\CaelusAdmin.algo.ts:329
	// i += 1
	frame_dig 3 // i: uint64
	intc 1 // 1
	+
	frame_bury 3 // i: uint64
	b *for_1

*for_1_end:
	// contracts\CaelusAdmin.algo.ts:352
	// amtLeft = this.getBurnAmount(amtToBurn - burning)
	frame_dig 0 // amtToBurn: uint64
	frame_dig 1 // burning: uint64
	-
	callsub getBurnAmount
	frame_bury 6 // amtLeft: uint64

	// *if9_condition
	// contracts\CaelusAdmin.algo.ts:353
	// amtLeft > 0
	frame_dig 6 // amtLeft: uint64
	intc 0 // 0
	>
	bz *if9_end

	// *if9_consequent
	// contracts\CaelusAdmin.algo.ts:354
	// this.pendingGroup.addAssetTransfer({
	//         xferAsset: this.vALGOid.value,
	//         assetAmount: amtLeft,
	//         assetReceiver: burnTxn.sender, // the sender needs to be the burnTxn sender, so when operator burns vALGO from the app it returns the amount left to burn
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:355
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:356
	// assetAmount: amtLeft
	frame_dig 6 // amtLeft: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:357
	// assetReceiver: burnTxn.sender
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns Sender
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:358
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts\CaelusAdmin.algo.ts:360
	// this.circulatingSupply.value -= burnTxn.assetAmount - amtLeft
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 6 // amtLeft: uint64
	-
	-
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:361
	// this.totalAlgoStaked.value -= burning
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig 1 // burning: uint64
	-
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:362
	// this.burnExhaust.value = true
	bytec 20 //  "burnExhaust"
	intc 1 // 1
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusAdmin.algo.ts:363
	// this.burnCooldownFromBlock.value = globals.round
	bytec 16 //  "burnCooldown"
	global Round
	app_global_put

	// contracts\CaelusAdmin.algo.ts:365
	// this.burnEvent.log({
	//         filled: amtLeft > 0,
	//         amount: burnTxn.assetAmount - amtLeft,
	//         output: burning,
	//       })
	bytec 25 //  burnEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 6 // amtLeft: uint64
	intc 0 // 0
	>
	setbit
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 6 // amtLeft: uint64
	-
	itob
	concat
	frame_dig 1 // burning: uint64
	itob
	concat
	concat
	log

	// contracts\CaelusAdmin.algo.ts:371
	// return;
	retsub

*if9_end:
	// contracts\CaelusAdmin.algo.ts:373
	// this.totalAlgoStaked.value -= burning
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig 1 // burning: uint64
	-
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:374
	// this.circulatingSupply.value -= burnTxn.assetAmount
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	-
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:376
	// this.burnEvent.log({
	//       filled: amtLeft > 0,
	//       amount: burnTxn.assetAmount,
	//       output: burning,
	//     })
	bytec 25 //  burnEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 6 // amtLeft: uint64
	intc 0 // 0
	>
	setbit
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	frame_dig 1 // burning: uint64
	itob
	concat
	concat
	log
	retsub

// mintValidatorCommit(uint64,pay)void
*abi_route_mintValidatorCommit:
	// stakeCommit: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (stakeCommit) for mintValidatorCommit must be a pay transaction
	assert

	// validatorAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute mintValidatorCommit(uint64,pay)void
	callsub mintValidatorCommit
	intc 1 // 1
	return

// mintValidatorCommit(validatorAppID: AppID, stakeCommit: PayTxn): void
mintValidatorCommit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:389
	// assert(this.isPool(validatorAppID))
	frame_dig -1 // validatorAppID: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:390
	// operatorAddress = validatorAppID.globalState('operatorAddress') as Address
	frame_dig -1 // validatorAppID: AppID
	bytec 27 //  "operatorAddress"
	app_global_get_ex

	// global state value does not exist: validatorAppID.globalState('operatorAddress')
	assert
	frame_bury 0 // operatorAddress: address

	// contracts\CaelusAdmin.algo.ts:391
	// verifyPayTxn(stakeCommit, {
	//       sender: operatorAddress,
	//       receiver: this.app.address,
	//     })
	// verify sender
	frame_dig -2 // stakeCommit: PayTxn
	gtxns Sender
	frame_dig 0 // operatorAddress: address
	==

	// transaction verification failed: {"txn":"stakeCommit","field":"sender","expected":"operatorAddress"}
	assert

	// verify receiver
	frame_dig -2 // stakeCommit: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"stakeCommit","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:396
	// sendMethodCall<typeof CaelusValidatorPool.prototype.addToOperatorCommit>({
	//       applicationID: validatorAppID,
	//       methodArgs: [
	//         {
	//           sender: this.app.address,
	//           receiver: validatorAppID.address,
	//           amount: stakeCommit.amount,
	//           fee: 0,
	//         },
	//       ],
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:400
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts\CaelusAdmin.algo.ts:401
	// receiver: validatorAppID.address
	frame_dig -1 // validatorAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts\CaelusAdmin.algo.ts:402
	// amount: stakeCommit.amount
	frame_dig -2 // stakeCommit: PayTxn
	gtxns Amount
	itxn_field Amount

	// contracts\CaelusAdmin.algo.ts:403
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xdfa20764 // method "addToOperatorCommit(pay)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:397
	// applicationID: validatorAppID
	frame_dig -1 // validatorAppID: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:398
	// methodArgs: [
	//         {
	//           sender: this.app.address,
	//           receiver: validatorAppID.address,
	//           amount: stakeCommit.amount,
	//           fee: 0,
	//         },
	//       ]
	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:408
	// amountToMint = this.getMintAmount(stakeCommit.amount)
	frame_dig -2 // stakeCommit: PayTxn
	gtxns Amount
	callsub getMintAmount
	frame_bury 1 // amountToMint: uint64

	// contracts\CaelusAdmin.algo.ts:409
	// sendAssetTransfer({
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: validatorAppID.address,
	//       assetAmount: amountToMint,
	//       fee: 0,
	//     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:410
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:411
	// assetReceiver: validatorAppID.address
	frame_dig -1 // validatorAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:412
	// assetAmount: amountToMint
	frame_dig 1 // amountToMint: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:413
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:415
	// this.totalAlgoStaked.value += stakeCommit.amount
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig -2 // stakeCommit: PayTxn
	gtxns Amount
	+
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:416
	// this.circulatingSupply.value += amountToMint
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig 1 // amountToMint: uint64
	+
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put
	retsub

// burnValidatorCommit(uint64,axfer)void
*abi_route_burnValidatorCommit:
	// burnTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 0 (burnTxn) for burnValidatorCommit must be a axfer transaction
	assert

	// appToBurnFrom: uint64
	txna ApplicationArgs 1
	btoi

	// execute burnValidatorCommit(uint64,axfer)void
	callsub burnValidatorCommit
	intc 1 // 1
	return

// burnValidatorCommit(appToBurnFrom: AppID, burnTxn: AssetTransferTxn): void
burnValidatorCommit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:424
	// this.isPool(appToBurnFrom)
	frame_dig -1 // appToBurnFrom: AppID
	callsub isPool

	// contracts\CaelusAdmin.algo.ts:426
	// verifyTxn(this.txn, {
	//       sender: appToBurnFrom.address,
	//     })
	// verify sender
	txn Sender
	frame_dig -1 // appToBurnFrom: AppID
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"appToBurnFrom.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:429
	// verifyAssetTransferTxn(burnTxn, {
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: this.app.address,
	//     })
	// verify xferAsset
	frame_dig -2 // burnTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 8 //  "vALGOid"
	app_global_get
	==

	// transaction verification failed: {"txn":"burnTxn","field":"xferAsset","expected":"this.vALGOid.value"}
	assert

	// verify assetReceiver
	frame_dig -2 // burnTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"burnTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:433
	// opCmt = appToBurnFrom.globalState('operatorCommit') as uint64
	frame_dig -1 // appToBurnFrom: AppID
	bytec 30 //  "operatorCommit"
	app_global_get_ex

	// global state value does not exist: appToBurnFrom.globalState('operatorCommit')
	assert
	frame_bury 0 // opCmt: uint64

	// contracts\CaelusAdmin.algo.ts:434
	// assert(!(appToBurnFrom.globalState('isDelinquent') as boolean), 'con only burn when delinquency is solved')
	frame_dig -1 // appToBurnFrom: AppID
	bytec 19 //  "isDelinquent"
	app_global_get_ex

	// global state value does not exist: appToBurnFrom.globalState('isDelinquent')
	assert
	!

	// con only burn when delinquency is solved
	assert

	// contracts\CaelusAdmin.algo.ts:435
	// toBurn = this.getBurnAmount(burnTxn.assetAmount)
	frame_dig -2 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	callsub getBurnAmount
	frame_bury 1 // toBurn: uint64

	// contracts\CaelusAdmin.algo.ts:436
	// assert(opCmt < toBurn && opCmt - toBurn > globals.payoutsMinBalance, 'cannot burn more than the committed amount')
	frame_dig 0 // opCmt: uint64
	frame_dig 1 // toBurn: uint64
	<
	dup
	bz *skip_and2
	frame_dig 0 // opCmt: uint64
	frame_dig 1 // toBurn: uint64
	-
	global PayoutsMinBalance
	>
	&&

*skip_and2:
	// cannot burn more than the committed amount
	assert

	// contracts\CaelusAdmin.algo.ts:437
	// sendMethodCall<typeof CaelusValidatorPool.prototype.removeFromOperatorCommit, void>({
	//       applicationID: appToBurnFrom,
	//       methodArgs: [toBurn],
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xf6786084 // method "removeFromOperatorCommit(uint64)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:438
	// applicationID: appToBurnFrom
	frame_dig -1 // appToBurnFrom: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:439
	// methodArgs: [toBurn]
	frame_dig 1 // toBurn: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:441
	// this.totalAlgoStaked.value -= toBurn
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig 1 // toBurn: uint64
	-
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:442
	// this.circulatingSupply.value -= burnTxn.assetAmount
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig -2 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	-
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put
	retsub

// burnToDelinquentValidator(axfer,uint64)void
*abi_route_burnToDelinquentValidator:
	// validatorAppID: uint64
	txna ApplicationArgs 1
	btoi

	// burnTxn: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (burnTxn) for burnToDelinquentValidator must be a axfer transaction
	assert

	// execute burnToDelinquentValidator(axfer,uint64)void
	callsub burnToDelinquentValidator
	intc 1 // 1
	return

// burnToDelinquentValidator(burnTxn: AssetTransferTxn, validatorAppID: AppID): void
burnToDelinquentValidator:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 6

	// contracts\CaelusAdmin.algo.ts:453
	// this.isPool(validatorAppID)
	frame_dig -2 // validatorAppID: AppID
	callsub isPool

	// contracts\CaelusAdmin.algo.ts:454
	// assert(globals.round - this.burnCooldownFromBlock.value > BURN_COOLDOW, "can only burn if we're not exhausted")
	global Round
	bytec 16 //  "burnCooldown"
	app_global_get
	-
	intc 6 // 10
	>

	// can only burn if we're not exhausted
	assert

	// contracts\CaelusAdmin.algo.ts:455
	// assert(burnTxn.sender === validatorAppID.address)
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns Sender
	frame_dig -2 // validatorAppID: AppID
	app_params_get AppAddress
	pop
	==
	assert

	// contracts\CaelusAdmin.algo.ts:456
	// assert(burnTxn.xferAsset === this.vALGOid.value)
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns XferAsset
	bytec 8 //  "vALGOid"
	app_global_get
	==
	assert

	// contracts\CaelusAdmin.algo.ts:457
	// assert(validatorAppID.globalState('isDelinquent') as boolean)
	frame_dig -2 // validatorAppID: AppID
	bytec 19 //  "isDelinquent"
	app_global_get_ex

	// global state value does not exist: validatorAppID.globalState('isDelinquent')
	assert
	assert

	// contracts\CaelusAdmin.algo.ts:458
	// amountToUpdate = 0
	intc 0 // 0
	frame_bury 0 // amountToUpdate: uint64

	// contracts\CaelusAdmin.algo.ts:459
	// toBurn = this.getBurnAmount(burnTxn.assetAmount)
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	callsub getBurnAmount
	frame_bury 1 // toBurn: uint64

	// contracts\CaelusAdmin.algo.ts:460
	// amtBurned = 0
	intc 0 // 0
	frame_bury 2 // amtBurned: uint64

	// *if10_condition
	// contracts\CaelusAdmin.algo.ts:461
	// this.isPool(this.burnPrio.value)
	bytec 4 //  "burnPrio"
	app_global_get
	callsub isPool
	bz *if10_end

	// *if10_consequent
	// contracts\CaelusAdmin.algo.ts:462
	// prioStake = this.burnPrio.value.globalState('delegatedStake') as uint64
	bytec 4 //  "burnPrio"
	app_global_get
	bytec 28 //  "delegatedStake"
	app_global_get_ex

	// global state value does not exist: this.burnPrio.value.globalState('delegatedStake')
	assert
	frame_bury 3 // prioStake: uint64

	// contracts\CaelusAdmin.algo.ts:463
	// amtBurned = prioStake >= toBurn ? prioStake : toBurn - prioStake
	frame_dig 3 // prioStake: uint64
	frame_dig 1 // toBurn: uint64
	>=
	bz *ternary0_false
	frame_dig 3 // prioStake: uint64
	b *ternary0_end

*ternary0_false:
	frame_dig 1 // toBurn: uint64
	frame_dig 3 // prioStake: uint64
	-

*ternary0_end:
	frame_bury 2 // amtBurned: uint64

	// contracts\CaelusAdmin.algo.ts:464
	// sendMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//         applicationID: this.burnPrio.value,
	//         methodArgs: [amtBurned, this.app.address],
	//         fee: 0,
	//       })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:465
	// applicationID: this.burnPrio.value
	bytec 4 //  "burnPrio"
	app_global_get
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:466
	// methodArgs: [amtBurned, this.app.address]
	frame_dig 2 // amtBurned: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:467
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:469
	// toBurn -= amtBurned
	frame_dig 1 // toBurn: uint64
	frame_dig 2 // amtBurned: uint64
	-
	frame_bury 1 // toBurn: uint64

*if10_end:
	// *if11_condition
	// contracts\CaelusAdmin.algo.ts:471
	// toBurn > 0
	frame_dig 1 // toBurn: uint64
	intc 0 // 0
	>
	bz *if11_end

	// *if11_consequent
	// contracts\CaelusAdmin.algo.ts:472
	// for (let i = 0; i < this.burnQueue.value.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_2:
	// contracts\CaelusAdmin.algo.ts:472
	// i < this.burnQueue.value.length
	frame_dig 4 // i: uint64
	intc 6 // 10
	<
	bz *for_2_end

	// contracts\CaelusAdmin.algo.ts:473
	// v = this.burnQueue.value[i]
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	frame_bury 5 // v: uint64

	// *if12_condition
	// contracts\CaelusAdmin.algo.ts:474
	// this.isPool(v)
	frame_dig 5 // v: uint64
	callsub isPool
	bz *if12_end

	// *if12_consequent
	// contracts\CaelusAdmin.algo.ts:475
	// dlgToV = v.globalState('delinquentStake') as uint64
	frame_dig 5 // v: uint64
	pushbytes 0x64656c696e7175656e745374616b65 // "delinquentStake"
	app_global_get_ex

	// global state value does not exist: v.globalState('delinquentStake')
	assert
	frame_bury 6 // dlgToV: uint64

	// *if13_condition
	// contracts\CaelusAdmin.algo.ts:476
	// dlgToV >= toBurn
	frame_dig 6 // dlgToV: uint64
	frame_dig 1 // toBurn: uint64
	>=
	bz *if13_else

	// *if13_consequent
	// contracts\CaelusAdmin.algo.ts:477
	// sendMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//               applicationID: v,
	//               methodArgs: [toBurn, this.app.address],
	//               fee: 0,
	//             })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:478
	// applicationID: v
	frame_dig 5 // v: uint64
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:479
	// methodArgs: [toBurn, this.app.address]
	frame_dig 1 // toBurn: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:480
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:482
	// amtBurned += toBurn
	frame_dig 2 // amtBurned: uint64
	frame_dig 1 // toBurn: uint64
	+
	frame_bury 2 // amtBurned: uint64

	// contracts\CaelusAdmin.algo.ts:483
	// toBurn = 0
	intc 0 // 0
	frame_bury 1 // toBurn: uint64
	b *for_2_end
	b *if13_end

*if13_else:
	// contracts\CaelusAdmin.algo.ts:486
	// sendMethodCall<typeof CaelusValidatorPool.prototype.burnStake, void>({
	//               applicationID: v,
	//               methodArgs: [dlgToV, this.app.address],
	//               fee: 0,
	//             })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 12 //  method "burnStake(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:487
	// applicationID: v
	frame_dig 5 // v: uint64
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:488
	// methodArgs: [dlgToV, this.app.address]
	frame_dig 6 // dlgToV: uint64
	itob
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:489
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:491
	// amtBurned += dlgToV
	frame_dig 2 // amtBurned: uint64
	frame_dig 6 // dlgToV: uint64
	+
	frame_bury 2 // amtBurned: uint64

	// contracts\CaelusAdmin.algo.ts:492
	// toBurn -= dlgToV
	frame_dig 1 // toBurn: uint64
	frame_dig 6 // dlgToV: uint64
	-
	frame_bury 1 // toBurn: uint64

*if13_end:

*if12_end:

*for_2_continue:
	// contracts\CaelusAdmin.algo.ts:472
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_2

*for_2_end:

*if11_end:
	// contracts\CaelusAdmin.algo.ts:497
	// amountToUpdate = this.getBurnAmount(toBurn - amtBurned)
	frame_dig 1 // toBurn: uint64
	frame_dig 2 // amtBurned: uint64
	-
	callsub getBurnAmount
	frame_bury 0 // amountToUpdate: uint64

	// contracts\CaelusAdmin.algo.ts:498
	// this.circulatingSupply.value -= burnTxn.assetAmount - amountToUpdate
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 0 // amountToUpdate: uint64
	-
	-
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:499
	// this.totalAlgoStaked.value -= amtBurned
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig 2 // amtBurned: uint64
	-
	bytec 1 //  "totalstake"
	swap
	app_global_put

	// *if14_condition
	// contracts\CaelusAdmin.algo.ts:500
	// amountToUpdate > 0
	frame_dig 0 // amountToUpdate: uint64
	intc 0 // 0
	>
	bz *if14_end

	// *if14_consequent
	// contracts\CaelusAdmin.algo.ts:501
	// sendAssetTransfer({
	//         xferAsset: this.vALGOid.value,
	//         assetReceiver: burnTxn.sender,
	//         assetAmount: amountToUpdate,
	//         fee: 0,
	//       })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:502
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:503
	// assetReceiver: burnTxn.sender
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns Sender
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:504
	// assetAmount: amountToUpdate
	frame_dig 0 // amountToUpdate: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:505
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if14_end:
	// contracts\CaelusAdmin.algo.ts:509
	// this.burnEvent.log({
	//       filled: amountToUpdate > 0,
	//       amount: burnTxn.assetAmount,
	//       output: amtBurned,
	//     })
	bytec 25 //  burnEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // amountToUpdate: uint64
	intc 0 // 0
	>
	setbit
	frame_dig -1 // burnTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	frame_dig 2 // amtBurned: uint64
	itob
	concat
	concat
	log
	retsub

// reMintDeliquentCommit(uint64,uint64)void
*abi_route_reMintDeliquentCommit:
	// app: uint64
	txna ApplicationArgs 2
	btoi

	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute reMintDeliquentCommit(uint64,uint64)void
	callsub reMintDeliquentCommit
	intc 1 // 1
	return

// reMintDeliquentCommit(amount: uint64, app: AppID): void
reMintDeliquentCommit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusAdmin.algo.ts:521
	// this.isPool(app)
	frame_dig -2 // app: AppID
	callsub isPool

	// contracts\CaelusAdmin.algo.ts:522
	// assert(!(app.globalState('isDelinquent') as boolean), 'must solve delinquency first')
	frame_dig -2 // app: AppID
	bytec 19 //  "isDelinquent"
	app_global_get_ex

	// global state value does not exist: app.globalState('isDelinquent')
	assert
	!

	// must solve delinquency first
	assert

	// contracts\CaelusAdmin.algo.ts:523
	// assert(
	//       amount === (app.globalState('operatorCommit') as uint64),
	//       'amount need to be the full amount of operatorCommit'
	//     )
	frame_dig -1 // amount: uint64
	frame_dig -2 // app: AppID
	bytec 30 //  "operatorCommit"
	app_global_get_ex

	// global state value does not exist: app.globalState('operatorCommit')
	assert
	==

	// amount need to be the full amount of operatorCommit
	assert

	// contracts\CaelusAdmin.algo.ts:527
	// assert((app.globalState('operatorAddress') as Address) === this.txn.sender)
	frame_dig -2 // app: AppID
	bytec 27 //  "operatorAddress"
	app_global_get_ex

	// global state value does not exist: app.globalState('operatorAddress')
	assert
	txn Sender
	==
	assert

	// contracts\CaelusAdmin.algo.ts:528
	// assert(
	//       app.address.assetBalance(this.vALGOid.value) === 0,
	//       'If the app already has vALGO it cannot mint with this method'
	//     )
	frame_dig -2 // app: AppID
	app_params_get AppAddress
	pop
	bytec 8 //  "vALGOid"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 0 // 0
	==

	// If the app already has vALGO it cannot mint with this method
	assert

	// contracts\CaelusAdmin.algo.ts:532
	// amountToMint = this.getMintAmount(amount)
	frame_dig -1 // amount: uint64
	callsub getMintAmount
	frame_bury 0 // amountToMint: uint64

	// contracts\CaelusAdmin.algo.ts:533
	// sendAssetTransfer({
	//       xferAsset: this.vALGOid.value,
	//       assetReceiver: app.address,
	//       assetAmount: amountToMint,
	//       fee: 0,
	//     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:534
	// xferAsset: this.vALGOid.value
	bytec 8 //  "vALGOid"
	app_global_get
	itxn_field XferAsset

	// contracts\CaelusAdmin.algo.ts:535
	// assetReceiver: app.address
	frame_dig -2 // app: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts\CaelusAdmin.algo.ts:536
	// assetAmount: amountToMint
	frame_dig 0 // amountToMint: uint64
	itxn_field AssetAmount

	// contracts\CaelusAdmin.algo.ts:537
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:539
	// this.circulatingSupply.value += amountToMint
	bytec 2 //  "circulatingSupply"
	app_global_get
	frame_dig 0 // amountToMint: uint64
	+
	bytec 2 //  "circulatingSupply"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:541
	// this.mintEvent.log({
	//       instant: true,
	//       amount: amount,
	//       output: amountToMint,
	//     })
	bytec 24 //  mintEvent(bool,uint64,uint64)
	bytec 5 // 0x00
	intc 0 // 0
	intc 1 // 1
	setbit
	frame_dig -1 // amount: uint64
	itob
	concat
	frame_dig 0 // amountToMint: uint64
	itob
	concat
	concat
	log
	retsub

// bid(uint64)void
*abi_route_bid:
	// validatorAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute bid(uint64)void
	callsub bid
	intc 1 // 1
	return

// bid(validatorAppID: AppID): void
bid:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\CaelusAdmin.algo.ts:551
	// assert(this.isPool(validatorAppID))
	frame_dig -1 // validatorAppID: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:552
	// isDelegatable = validatorAppID.globalState('canBeDelegated') as boolean
	frame_dig -1 // validatorAppID: AppID
	pushbytes 0x63616e426544656c656761746564 // "canBeDelegated"
	app_global_get_ex

	// global state value does not exist: validatorAppID.globalState('canBeDelegated')
	assert
	frame_bury 0 // isDelegatable: bool

	// *if15_condition
	// contracts\CaelusAdmin.algo.ts:553
	// this.isPool(this.highestBidder.value)
	bytec 11 //  "highestBidder"
	app_global_get
	callsub isPool
	bz *if15_end

	// *if15_consequent
	// contracts\CaelusAdmin.algo.ts:554
	// this.highestBidder.value = validatorAppID
	bytec 11 //  "highestBidder"
	frame_dig -1 // validatorAppID: AppID
	app_global_put

	// contracts\CaelusAdmin.algo.ts:555
	// return;
	retsub

*if15_end:
	// contracts\CaelusAdmin.algo.ts:557
	// valueC = validatorAppID.globalState('saturationBuffer') as uint64
	frame_dig -1 // validatorAppID: AppID
	bytec 13 //  "saturationBuffer"
	app_global_get_ex

	// global state value does not exist: validatorAppID.globalState('saturationBuffer')
	assert
	frame_bury 1 // valueC: uint64

	// contracts\CaelusAdmin.algo.ts:558
	// valueB = this.highestBidder.value.globalState('saturationBuffer') as uint64
	bytec 11 //  "highestBidder"
	app_global_get
	bytec 13 //  "saturationBuffer"
	app_global_get_ex

	// global state value does not exist: this.highestBidder.value.globalState('saturationBuffer')
	assert
	frame_bury 2 // valueB: uint64

	// contracts\CaelusAdmin.algo.ts:559
	// assert(isDelegatable, 'only bid delegatable Apps')
	frame_dig 0 // isDelegatable: bool

	// only bid delegatable Apps
	assert

	// *if16_condition
	// contracts\CaelusAdmin.algo.ts:560
	// valueC > valueB
	frame_dig 1 // valueC: uint64
	frame_dig 2 // valueB: uint64
	>
	bz *if16_end

	// *if16_consequent
	// contracts\CaelusAdmin.algo.ts:561
	// this.highestBidder.value = validatorAppID
	bytec 11 //  "highestBidder"
	frame_dig -1 // validatorAppID: AppID
	app_global_put

*if16_end:
	// contracts\CaelusAdmin.algo.ts:564
	// this.bidEvent.log({
	//       app: validatorAppID,
	//       isHeighest: this.highestBidder.value === validatorAppID,
	//     })
	pushbytes 0x76e08961 // bidEvent(uint64,bool)
	frame_dig -1 // validatorAppID: AppID
	itob
	bytec 5 // 0x00
	intc 0 // 0
	bytec 11 //  "highestBidder"
	app_global_get
	frame_dig -1 // validatorAppID: AppID
	==
	setbit
	concat
	concat
	log
	retsub

// delegateStake(uint64,uint64)void
*abi_route_delegateStake:
	// validatorAppID: uint64
	txna ApplicationArgs 2
	btoi

	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute delegateStake(uint64,uint64)void
	callsub delegateStake
	intc 1 // 1
	return

// delegateStake(amount: uint64, validatorAppID: AppID): void
delegateStake:
	proto 2 0

	// contracts\CaelusAdmin.algo.ts:572
	// assert(this.isPool(validatorAppID))
	frame_dig -2 // validatorAppID: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:573
	// assert(validatorAppID === this.highestBidder.value, 'can only delegate to highest bidder account')
	frame_dig -2 // validatorAppID: AppID
	bytec 11 //  "highestBidder"
	app_global_get
	==

	// can only delegate to highest bidder account
	assert

	// contracts\CaelusAdmin.algo.ts:574
	// assert(amount <= this.idleAlgoToStake.value, 'cant withdraw more than the amount of idleAlgo in the contract')
	frame_dig -1 // amount: uint64
	bytec 3 //  "idleAlgo"
	app_global_get
	<=

	// cant withdraw more than the amount of idleAlgo in the contract
	assert

	// contracts\CaelusAdmin.algo.ts:575
	// sendMethodCall<typeof CaelusValidatorPool.prototype.addStake, void>({
	//       applicationID: validatorAppID,
	//       methodArgs: [
	//         {
	//           receiver: validatorAppID.address,
	//           amount: amount,
	//           fee: 0,
	//         },
	//       ],
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:579
	// receiver: validatorAppID.address
	frame_dig -2 // validatorAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts\CaelusAdmin.algo.ts:580
	// amount: amount
	frame_dig -1 // amount: uint64
	itxn_field Amount

	// contracts\CaelusAdmin.algo.ts:581
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xd4502100 // method "addStake(pay)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:576
	// applicationID: validatorAppID
	frame_dig -2 // validatorAppID: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:577
	// methodArgs: [
	//         {
	//           receiver: validatorAppID.address,
	//           amount: amount,
	//           fee: 0,
	//         },
	//       ]
	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:585
	// this.idleAlgoToStake.value -= amount
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig -1 // amount: uint64
	-
	bytec 3 //  "idleAlgo"
	swap
	app_global_put
	retsub

// snitchToBurn(uint64)void
*abi_route_snitchToBurn:
	// app: uint64
	txna ApplicationArgs 1
	btoi

	// execute snitchToBurn(uint64)void
	callsub snitchToBurn
	intc 1 // 1
	return

// snitchToBurn(app: AppID): void
snitchToBurn:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts\CaelusAdmin.algo.ts:590
	// assert(this.isPool(app))
	frame_dig -1 // app: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:591
	// satSnitch = app.globalState('saturationBuffer') as uint64
	frame_dig -1 // app: AppID
	bytec 13 //  "saturationBuffer"
	app_global_get_ex

	// global state value does not exist: app.globalState('saturationBuffer')
	assert
	frame_bury 0 // satSnitch: uint64

	// contracts\CaelusAdmin.algo.ts:592
	// minPrio = app
	frame_dig -1 // app: AppID
	frame_bury 1 // minPrio: uint64

	// contracts\CaelusAdmin.algo.ts:593
	// minSat = satSnitch
	frame_dig 0 // satSnitch: uint64
	frame_bury 2 // minSat: uint64

	// *if17_condition
	// contracts\CaelusAdmin.algo.ts:594
	// this.isPool(this.burnPrio.value)
	bytec 4 //  "burnPrio"
	app_global_get
	callsub isPool
	bz *if17_end

	// *if17_consequent
	// contracts\CaelusAdmin.algo.ts:595
	// satPrio = this.burnPrio.value.globalState('saturationBuffer') as uint64
	bytec 4 //  "burnPrio"
	app_global_get
	bytec 13 //  "saturationBuffer"
	app_global_get_ex

	// global state value does not exist: this.burnPrio.value.globalState('saturationBuffer')
	assert
	frame_bury 3 // satPrio: uint64

	// *if18_condition
	// contracts\CaelusAdmin.algo.ts:596
	// satSnitch > satPrio
	frame_dig 0 // satSnitch: uint64
	frame_dig 3 // satPrio: uint64
	>
	bz *if18_end

	// *if18_consequent
	// contracts\CaelusAdmin.algo.ts:597
	// minPrio = this.burnPrio.value
	bytec 4 //  "burnPrio"
	app_global_get
	frame_bury 1 // minPrio: uint64

	// contracts\CaelusAdmin.algo.ts:598
	// minSat = satPrio
	frame_dig 3 // satPrio: uint64
	frame_bury 2 // minSat: uint64

	// contracts\CaelusAdmin.algo.ts:599
	// this.burnPrio.value = app
	bytec 4 //  "burnPrio"
	frame_dig -1 // app: AppID
	app_global_put

*if18_end:

*if17_end:
	// contracts\CaelusAdmin.algo.ts:603
	// for (let i = 0; i < queue.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_3:
	// contracts\CaelusAdmin.algo.ts:603
	// i < queue.length
	frame_dig 4 // i: uint64
	intc 6 // 10
	<
	bz *for_3_end

	// *if19_condition
	// contracts\CaelusAdmin.algo.ts:604
	// !this.isPool(queue[i])
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	callsub isPool
	!
	bz *if19_end

	// *if19_consequent
	// contracts\CaelusAdmin.algo.ts:605
	// queue[i] = minPrio
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	frame_dig 1 // minPrio: uint64
	itob
	bytec 6 //  "burnQueue"
	cover 2
	box_replace
	b *for_3_end

*if19_end:
	// *if20_condition
	// contracts\CaelusAdmin.algo.ts:608
	// (queue[i].globalState('saturationBuffer') as uint64) < minSat
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	bytec 13 //  "saturationBuffer"
	app_global_get_ex

	// global state value does not exist: queue[i].globalState('saturationBuffer')
	assert
	frame_dig 2 // minSat: uint64
	<
	bz *if20_end

	// *if20_consequent
	// contracts\CaelusAdmin.algo.ts:609
	// temp = minPrio
	frame_dig 1 // minPrio: uint64
	frame_bury 5 // temp: uint64

	// contracts\CaelusAdmin.algo.ts:610
	// minPrio = queue[i]
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	frame_bury 1 // minPrio: uint64

	// contracts\CaelusAdmin.algo.ts:611
	// queue[i] = temp
	frame_dig 4 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	frame_dig 5 // temp: uint64
	itob
	bytec 6 //  "burnQueue"
	cover 2
	box_replace

*if20_end:

*for_3_continue:
	// contracts\CaelusAdmin.algo.ts:603
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_3

*for_3_end:
	// contracts\CaelusAdmin.algo.ts:615
	// this.snitchQueueEvent.log({
	//       prio: this.burnPrio.value,
	//       queue: this.burnQueue.value,
	//     })
	pushbytes 0x06777db0 // snitchQueueEvent(uint64,uint64[10])
	bytec 4 //  "burnPrio"
	app_global_get
	itob
	bytec 6 //  "burnQueue"
	box_get

	// box value does not exist: this.burnQueue.value
	assert
	concat
	concat
	log
	retsub

// multiSnitchToBurn(uint64[])void
*abi_route_multiSnitchToBurn:
	// apps: uint64[]
	txna ApplicationArgs 1
	extract 2 0

	// execute multiSnitchToBurn(uint64[])void
	callsub multiSnitchToBurn
	intc 1 // 1
	return

// multiSnitchToBurn(apps: AppID[]): void
multiSnitchToBurn:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:625
	// for (let i = 0; i < apps.length; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_4:
	// contracts\CaelusAdmin.algo.ts:625
	// i < apps.length
	frame_dig 0 // i: uint64
	frame_dig -1 // apps: AppID[]
	len
	intc 2 // 8
	/
	<
	bz *for_4_end

	// contracts\CaelusAdmin.algo.ts:626
	// v = apps[i]
	frame_dig -1 // apps: AppID[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 0 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 2 // 8
	extract3
	btoi
	frame_bury 1 // v: uint64

	// contracts\CaelusAdmin.algo.ts:627
	// assert(this.isPool(v))
	frame_dig 1 // v: uint64
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:628
	// this.snitchToBurn(v)
	frame_dig 1 // v: uint64
	callsub snitchToBurn

*for_4_continue:
	// contracts\CaelusAdmin.algo.ts:625
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_4

*for_4_end:
	retsub

// reStakeFromSnitch(uint64,uint64,pay)void
*abi_route_reStakeFromSnitch:
	// restakeTxn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (restakeTxn) for reStakeFromSnitch must be a pay transaction
	assert

	// receiverApp: uint64
	txna ApplicationArgs 2
	btoi

	// snitchedApp: uint64
	txna ApplicationArgs 1
	btoi

	// execute reStakeFromSnitch(uint64,uint64,pay)void
	callsub reStakeFromSnitch
	intc 1 // 1
	return

// reStakeFromSnitch(snitchedApp: AppID, receiverApp: AppID, restakeTxn: PayTxn): void
reStakeFromSnitch:
	proto 3 0

	// contracts\CaelusAdmin.algo.ts:634
	// assert(this.isPool(snitchedApp))
	frame_dig -1 // snitchedApp: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:635
	// assert(receiverApp.address === restakeTxn.receiver)
	frame_dig -2 // receiverApp: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Receiver
	==
	assert

	// *if21_condition
	// contracts\CaelusAdmin.algo.ts:636
	// restakeTxn.receiver !== this.app.address
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	!=
	bz *if21_end

	// *if21_consequent
	// contracts\CaelusAdmin.algo.ts:637
	// sendMethodCall<typeof CaelusValidatorPool.prototype.getClawbackedStake, void>({
	//         applicationID: receiverApp,
	//         methodArgs: [
	//           {
	//             receiver: restakeTxn.receiver,
	//             amount: restakeTxn.amount,
	//             fee: 0,
	//           },
	//         ],
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:641
	// receiver: restakeTxn.receiver
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Receiver
	itxn_field Receiver

	// contracts\CaelusAdmin.algo.ts:642
	// amount: restakeTxn.amount
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Amount
	itxn_field Amount

	// contracts\CaelusAdmin.algo.ts:643
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xbdf01e8e // method "getClawbackedStake(pay)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:638
	// applicationID: receiverApp
	frame_dig -2 // receiverApp: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:639
	// methodArgs: [
	//           {
	//             receiver: restakeTxn.receiver,
	//             amount: restakeTxn.amount,
	//             fee: 0,
	//           },
	//         ]
	// contracts\CaelusAdmin.algo.ts:646
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:648
	// return;
	retsub

*if21_end:
	// contracts\CaelusAdmin.algo.ts:650
	// verifyPayTxn(restakeTxn, {
	//       sender: snitchedApp.address,
	//       receiver: this.app.address,
	//     })
	// verify sender
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Sender
	frame_dig -1 // snitchedApp: AppID
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"restakeTxn","field":"sender","expected":"snitchedApp.address"}
	assert

	// verify receiver
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"restakeTxn","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:654
	// this.idleAlgoToStake.value += restakeTxn.amount
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig -3 // restakeTxn: PayTxn
	gtxns Amount
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put
	retsub

// onOperatorExit(uint64,pay)void
*abi_route_onOperatorExit:
	// closeTxn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (closeTxn) for onOperatorExit must be a pay transaction
	assert

	// appToClose: uint64
	txna ApplicationArgs 1
	btoi

	// execute onOperatorExit(uint64,pay)void
	callsub onOperatorExit
	intc 1 // 1
	return

// onOperatorExit(appToClose: AppID, closeTxn: PayTxn): void
onOperatorExit:
	proto 2 0

	// contracts\CaelusAdmin.algo.ts:659
	// verifyTxn(this.txn, {
	//       sender: appToClose.address,
	//       receiver: this.app.address,
	//     })
	// verify sender
	txn Sender
	frame_dig -1 // appToClose: AppID
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"appToClose.address"}
	assert

	// verify receiver
	txn Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusAdmin.algo.ts:663
	// this.idleAlgoToStake.value += closeTxn.amount
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig -2 // closeTxn: PayTxn
	gtxns Amount
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:664
	// sendMethodCall<typeof CaelusValidatorPool.prototype.deleteApplication, void>({
	//       applicationID: appToClose,
	//       methodArgs: [],
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x2487c32c // method "deleteApplication()void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:665
	// applicationID: appToClose
	frame_dig -1 // appToClose: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:666
	// methodArgs: []
	// contracts\CaelusAdmin.algo.ts:667
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// declareRewards(pay,uint64)void
*abi_route_declareRewards:
	// ifValidator: uint64
	txna ApplicationArgs 1
	btoi

	// txn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (txn) for declareRewards must be a pay transaction
	assert

	// execute declareRewards(pay,uint64)void
	callsub declareRewards
	intc 1 // 1
	return

// declareRewards(txn: PayTxn, ifValidator: uint64): void
declareRewards:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusAdmin.algo.ts:672
	// assert(txn.receiver === this.app.address, 'payment must be done to this app address')
	frame_dig -1 // txn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// payment must be done to this app address
	assert

	// contracts\CaelusAdmin.algo.ts:673
	// restakeRewards = txn.amount
	frame_dig -1 // txn: PayTxn
	gtxns Amount
	frame_bury 0 // restakeRewards: uint64

	// contracts\CaelusAdmin.algo.ts:674
	// assert(
	//       (this.isPool(AppID.fromUint64(ifValidator)) && AppID.fromUint64(ifValidator).address === this.txn.sender) ||
	//         ifValidator === 0,
	//       'either the caller is a Caelus Pool App or set the second param to 0 '
	//     )
	frame_dig -2 // ifValidator: uint64
	callsub isPool
	dup
	bz *skip_and3
	frame_dig -2 // ifValidator: uint64
	app_params_get AppAddress
	pop
	txn Sender
	==
	&&

*skip_and3:
	dup
	bnz *skip_or1
	frame_dig -2 // ifValidator: uint64
	intc 0 // 0
	==
	||

*skip_or1:
	// either the caller is a Caelus Pool App or set the second param to 0
	assert

	// contracts\CaelusAdmin.algo.ts:679
	// protocolCut = wideRatio([PROTOCOL_COMMISSION, txn.amount], [100])
	intc 4 // 4
	frame_dig -1 // txn: PayTxn
	gtxns Amount
	mulw
	intc 0 // 0
	pushint 100
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // protocolCut: uint64

	// *if22_condition
	// contracts\CaelusAdmin.algo.ts:680
	// this.isPool(AppID.fromUint64(ifValidator))
	frame_dig -2 // ifValidator: uint64
	callsub isPool
	bz *if22_end

	// *if22_consequent
	// contracts\CaelusAdmin.algo.ts:681
	// restakeRewards -= protocolCut
	frame_dig 0 // restakeRewards: uint64
	frame_dig 1 // protocolCut: uint64
	-
	frame_bury 0 // restakeRewards: uint64

	// contracts\CaelusAdmin.algo.ts:682
	// sendPayment({
	//         receiver: this.vestigeAddress.value,
	//         amount: protocolCut,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusAdmin.algo.ts:683
	// receiver: this.vestigeAddress.value
	bytec 15 //  "vestigeAddress"
	app_global_get
	itxn_field Receiver

	// contracts\CaelusAdmin.algo.ts:684
	// amount: protocolCut
	frame_dig 1 // protocolCut: uint64
	itxn_field Amount

	// contracts\CaelusAdmin.algo.ts:685
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if22_end:
	// contracts\CaelusAdmin.algo.ts:689
	// this.idleAlgoToStake.value += restakeRewards
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig 0 // restakeRewards: uint64
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:690
	// this.totalAlgoStaked.value += restakeRewards
	bytec 1 //  "totalstake"
	app_global_get
	frame_dig 0 // restakeRewards: uint64
	+
	bytec 1 //  "totalstake"
	swap
	app_global_put
	retsub

// snitchCheck(uint64,(bool,bool,bool,uint64,bool,uint64))bool
*abi_route_snitchCheck:
	// The ABI return prefix
	bytec 14 // 0x151f7c75

	// params: (bool,bool,bool,uint64,bool,uint64)
	txna ApplicationArgs 2
	dup
	len
	pushint 18
	==

	// argument 0 (params) for snitchCheck must be a (bool,bool,bool,uint64,bool,uint64)
	assert

	// appToCheck: uint64
	txna ApplicationArgs 1
	btoi

	// execute snitchCheck(uint64,(bool,bool,bool,uint64,bool,uint64))bool
	callsub snitchCheck
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// snitchCheck(appToCheck: AppID, params: SnitchInfo): boolean
snitchCheck:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusAdmin.algo.ts:694
	// assert(this.isPool(appToCheck))
	frame_dig -1 // appToCheck: AppID
	callsub isPool
	assert

	// contracts\CaelusAdmin.algo.ts:695
	// assert(this.isPool(params.recipient) || params.recipient.address === this.app.address)
	frame_dig -2 // params: SnitchInfo
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	callsub isPool
	dup
	bnz *skip_or2
	frame_dig -2 // params: SnitchInfo
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	app_params_get AppAddress
	pop
	global CurrentApplicationAddress
	==
	||

*skip_or2:
	assert

	// contracts\CaelusAdmin.algo.ts:697
	// result = sendMethodCall<typeof CaelusValidatorPool.prototype.getSnitched, boolean>({
	//       applicationID: appToCheck,
	//       methodArgs: [params],
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x5b674f2f // method "getSnitched((bool,bool,bool,uint64,bool,uint64))bool"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:698
	// applicationID: appToCheck
	frame_dig -1 // appToCheck: AppID
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:699
	// methodArgs: [params]
	frame_dig -2 // params: SnitchInfo
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:700
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	frame_bury 0 // result: bool

	// contracts\CaelusAdmin.algo.ts:703
	// this.snitchValidatorEvent.log({
	//       request: params,
	//       result: result,
	//     })
	pushbytes 0x9ae707a2 // snitchValidatorEvent((bool,bool,bool,uint64,bool,uint64),bool)
	frame_dig -2 // params: SnitchInfo
	bytec 5 // 0x00
	intc 0 // 0
	frame_dig 0 // result: bool
	setbit
	concat
	concat
	log

	// contracts\CaelusAdmin.algo.ts:708
	// return result;
	frame_dig 0 // result: bool

	// set the subroutine return value
	frame_bury 0
	retsub

// makeFlashLoanRequest(pay,uint64[],uint64[])void
*abi_route_makeFlashLoanRequest:
	// appToInclude: uint64[]
	txna ApplicationArgs 2
	extract 2 0

	// amounts: uint64[]
	txna ApplicationArgs 1
	extract 2 0

	// payFeeTxn: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (payFeeTxn) for makeFlashLoanRequest must be a pay transaction
	assert

	// execute makeFlashLoanRequest(pay,uint64[],uint64[])void
	callsub makeFlashLoanRequest
	intc 1 // 1
	return

// makeFlashLoanRequest(payFeeTxn: PayTxn, amounts: uint64[], appToInclude: AppID[]): void
makeFlashLoanRequest:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\CaelusAdmin.algo.ts:713
	// this.getFLcounter()
	callsub getFLcounter
	pop

	// contracts\CaelusAdmin.algo.ts:714
	// this.flashLoanCounter.value += appToInclude.length
	bytec 7 //  "flashLoanCounter"
	app_global_get
	frame_dig -3 // appToInclude: AppID[]
	len
	intc 2 // 8
	/
	+
	bytec 7 //  "flashLoanCounter"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:715
	// keepFee = this.flashLoanCounter.value + FLASH_LOAN_FEE
	bytec 7 //  "flashLoanCounter"
	app_global_get
	pushint 10000000
	+
	frame_bury 0 // keepFee: uint64

	// contracts\CaelusAdmin.algo.ts:717
	// verifyPayTxn(payFeeTxn, {
	//       receiver: this.app.address,
	//       amount: keepFee,
	//     })
	// verify receiver
	frame_dig -1 // payFeeTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payFeeTxn","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payFeeTxn: PayTxn
	gtxns Amount
	frame_dig 0 // keepFee: uint64
	==

	// transaction verification failed: {"txn":"payFeeTxn","field":"amount","expected":"keepFee"}
	assert

	// contracts\CaelusAdmin.algo.ts:722
	// this.idleAlgoToStake.value += keepFee
	bytec 3 //  "idleAlgo"
	app_global_get
	frame_dig 0 // keepFee: uint64
	+
	bytec 3 //  "idleAlgo"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:724
	// assert(amounts.length === appToInclude.length, 'array length [amount, appToInclude] mismatch')
	frame_dig -2 // amounts: uint64[]
	len
	intc 2 // 8
	/
	frame_dig -3 // appToInclude: AppID[]
	len
	intc 2 // 8
	/
	==

	// array length [amount, appToInclude] mismatch
	assert

	// contracts\CaelusAdmin.algo.ts:726
	// for (let i = 0; i < appToInclude.length; i += 1)
	intc 0 // 0
	frame_bury 1 // i: uint64

*for_5:
	// contracts\CaelusAdmin.algo.ts:726
	// i < appToInclude.length
	frame_dig 1 // i: uint64
	frame_dig -3 // appToInclude: AppID[]
	len
	intc 2 // 8
	/
	<
	bz *for_5_end

	// contracts\CaelusAdmin.algo.ts:727
	// this.pendingGroup.addMethodCall<typeof CaelusValidatorPool.prototype.flashloan, void>({
	//         applicationID: appToInclude[i],
	//         methodArgs: [amounts[i], this.txn.sender],
	//         fee: 0,
	//       })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x4a5356cc // method "flashloan(uint64,address)void"
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:728
	// applicationID: appToInclude[i]
	frame_dig -3 // appToInclude: AppID[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 1 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 2 // 8
	extract3
	btoi
	itxn_field ApplicationID

	// contracts\CaelusAdmin.algo.ts:729
	// methodArgs: [amounts[i], this.txn.sender]
	frame_dig -2 // amounts: uint64[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 1 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 2 // 8
	extract3
	btoi
	itob
	itxn_field ApplicationArgs
	txn Sender
	itxn_field ApplicationArgs

	// contracts\CaelusAdmin.algo.ts:730
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts\CaelusAdmin.algo.ts:733
	// for (let j = this.txn.groupIndex; j < this.txnGroup.length; j += 1)
	txn GroupIndex
	frame_bury 2 // j: uint64

*for_6:
	// contracts\CaelusAdmin.algo.ts:733
	// j < this.txnGroup.length
	frame_dig 2 // j: uint64
	global GroupSize
	<
	bz *for_6_end

	// contracts\CaelusAdmin.algo.ts:734
	// txn = this.txnGroup[j]
	frame_dig 2 // j: uint64
	frame_bury 3 // txn: txn

	// contracts\CaelusAdmin.algo.ts:735
	// repaid = false
	intc 0 // 0
	frame_bury 4 // repaid: bool

	// *if23_condition
	// contracts\CaelusAdmin.algo.ts:737
	// txn.typeEnum === TransactionType.ApplicationCall &&
	//           txn.applicationID === appToInclude[i] &&
	//           txn.onCompletion === 0 &&
	//           txn.numAppArgs === 1 &&
	//           txn.applicationArgs[0] === method('checkBalance():void')
	frame_dig 3 // txn: txn
	gtxns TypeEnum
	intc 3 //  appl
	==
	dup
	bz *skip_and4
	frame_dig 3 // txn: txn
	gtxns ApplicationID
	frame_dig -3 // appToInclude: AppID[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 1 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 2 // 8
	extract3
	btoi
	==
	&&

*skip_and4:
	dup
	bz *skip_and5
	frame_dig 3 // txn: txn
	gtxns OnCompletion
	intc 0 // 0
	==
	&&

*skip_and5:
	dup
	bz *skip_and6
	frame_dig 3 // txn: txn
	gtxns NumAppArgs
	intc 1 // 1
	==
	&&

*skip_and6:
	dup
	bz *skip_and7
	frame_dig 3 // txn: txn
	gtxns ApplicationArgs 0
	pushbytes 0x3fa88fd0 // method "checkBalance():void"
	==
	&&

*skip_and7:
	bz *if23_end

	// *if23_consequent
	// contracts\CaelusAdmin.algo.ts:743
	// repaid = true
	intc 1 // 1
	frame_bury 4 // repaid: bool

*if23_end:
	// contracts\CaelusAdmin.algo.ts:745
	// assert(repaid)
	frame_dig 4 // repaid: bool
	assert

*for_6_continue:
	// contracts\CaelusAdmin.algo.ts:733
	// j += 1
	frame_dig 2 // j: uint64
	intc 1 // 1
	+
	frame_bury 2 // j: uint64
	b *for_6

*for_6_end:

*for_5_continue:
	// contracts\CaelusAdmin.algo.ts:726
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_5

*for_5_end:
	// contracts\CaelusAdmin.algo.ts:748
	// this.pendingGroup.submit()
	itxn_submit

	// contracts\CaelusAdmin.algo.ts:749
	// this.flashLoanEvent.log({ apps: appToInclude, amounts: amounts })
	pushbytes 0xaa4e641a // flashLoanEvent(uint64[],uint64[])
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0004 // initial head offset
	frame_dig -3 // appToInclude: AppID[]
	dup
	len
	intc 2 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // amounts: uint64[]
	dup
	len
	intc 2 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// getFLcounter()uint64
*abi_route_getFLcounter:
	// The ABI return prefix
	bytec 14 // 0x151f7c75

	// execute getFLcounter()uint64
	callsub getFLcounter
	itob
	concat
	log
	intc 1 // 1
	return

// getFLcounter(): uint64
getFLcounter:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// *if24_condition
	// contracts\CaelusAdmin.algo.ts:756
	// this.lastFlashloanBlock.value === globals.round
	bytec 26 //  "lastFlashloanBlock"
	app_global_get
	global Round
	==
	bz *if24_end

	// *if24_consequent
	// contracts\CaelusAdmin.algo.ts:757
	// return this.flashLoanCounter.value;
	bytec 7 //  "flashLoanCounter"
	app_global_get
	b *getFLcounter*return

*if24_end:
	// contracts\CaelusAdmin.algo.ts:759
	// reduce = globals.round - this.lastFlashloanBlock.value
	global Round
	bytec 26 //  "lastFlashloanBlock"
	app_global_get
	-
	frame_bury 0 // reduce: uint64

	// *if25_condition
	// contracts\CaelusAdmin.algo.ts:760
	// reduce > this.flashLoanCounter.value
	frame_dig 0 // reduce: uint64
	bytec 7 //  "flashLoanCounter"
	app_global_get
	>
	bz *if25_end

	// *if25_consequent
	// contracts\CaelusAdmin.algo.ts:761
	// this.flashLoanCounter.value = 0
	bytec 7 //  "flashLoanCounter"
	intc 0 // 0
	app_global_put

	// contracts\CaelusAdmin.algo.ts:762
	// return this.flashLoanCounter.value;
	bytec 7 //  "flashLoanCounter"
	app_global_get
	b *getFLcounter*return

*if25_end:
	// contracts\CaelusAdmin.algo.ts:764
	// this.flashLoanCounter.value -= reduce * 2 > this.flashLoanCounter.value ? reduce * 2 : reduce
	bytec 7 //  "flashLoanCounter"
	app_global_get
	frame_dig 0 // reduce: uint64
	intc 9 // 2
	*
	bytec 7 //  "flashLoanCounter"
	app_global_get
	>
	bz *ternary2_false
	frame_dig 0 // reduce: uint64
	intc 9 // 2
	*
	b *ternary2_end

*ternary2_false:
	frame_dig 0 // reduce: uint64

*ternary2_end:
	-
	bytec 7 //  "flashLoanCounter"
	swap
	app_global_put

	// contracts\CaelusAdmin.algo.ts:765
	// return this.flashLoanCounter.value;
	bytec 7 //  "flashLoanCounter"
	app_global_get

*getFLcounter*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// isPool(app: AppID): boolean
isPool:
	proto 1 1

	// contracts\CaelusAdmin.algo.ts:769
	// return app.creator === this.app.address;
	frame_dig -1 // app: AppID
	app_params_get AppCreator
	pop
	global CurrentApplicationAddress
	==
	retsub

// queueIsFull(): boolean
queueIsFull:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\CaelusAdmin.algo.ts:773
	// prioIsSet = this.isPool(this.burnPrio.value)
	bytec 4 //  "burnPrio"
	app_global_get
	callsub isPool
	frame_bury 0 // prioIsSet: bool

	// contracts\CaelusAdmin.algo.ts:774
	// queueIsFull = true
	intc 1 // 1
	frame_bury 1 // queueIsFull: bool

	// contracts\CaelusAdmin.algo.ts:775
	// for (let i = 0; i < this.burnQueue.value.length; i += 1)
	intc 0 // 0
	frame_bury 2 // i: uint64

*for_7:
	// contracts\CaelusAdmin.algo.ts:775
	// i < this.burnQueue.value.length
	frame_dig 2 // i: uint64
	intc 6 // 10
	<
	bz *for_7_end

	// contracts\CaelusAdmin.algo.ts:776
	// queueIsFull = this.isPool(this.burnQueue.value[i])
	frame_dig 2 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	bytec 6 //  "burnQueue"
	cover 2
	box_extract
	btoi
	callsub isPool
	frame_bury 1 // queueIsFull: bool

	// *if26_condition
	// contracts\CaelusAdmin.algo.ts:777
	// !queueIsFull
	frame_dig 1 // queueIsFull: bool
	!
	bz *if26_end

	// *if26_consequent
	b *for_7_end

*if26_end:

*for_7_continue:
	// contracts\CaelusAdmin.algo.ts:775
	// i += 1
	frame_dig 2 // i: uint64
	intc 1 // 1
	+
	frame_bury 2 // i: uint64
	b *for_7

*for_7_end:
	// contracts\CaelusAdmin.algo.ts:781
	// return prioIsSet && queueIsFull;
	frame_dig 0 // prioIsSet: bool
	dup
	bz *skip_and8
	frame_dig 1 // queueIsFull: bool
	&&

*skip_and8:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// minBalanceForAccount(contracts: uint64, extraPages: uint64, assets: uint64, localInts: uint64, localBytes: uint64, globalInts: uint64, globalBytes: uint64): uint64
minBalanceForAccount:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusAdmin.algo.ts:793
	// minBal = ALGORAND_ACCOUNT_MIN_BALANCE
	intc 5 // 100000
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:794
	// minBal += contracts * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -1 // contracts: uint64
	intc 5 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:795
	// minBal += extraPages * APPLICATION_BASE_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -2 // extraPages: uint64
	intc 5 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:796
	// minBal += assets * ASSET_HOLDING_FEE
	frame_dig 0 // minBal: uint64
	frame_dig -3 // assets: uint64
	intc 5 // 100000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:797
	// minBal += localInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -4 // localInts: uint64
	intc 13 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:798
	// minBal += globalInts * SSC_VALUE_UINT
	frame_dig 0 // minBal: uint64
	frame_dig -6 // globalInts: uint64
	intc 13 // 28500
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:799
	// minBal += localBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -5 // localBytes: uint64
	intc 14 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:800
	// minBal += globalBytes * SSC_VALUE_BYTES
	frame_dig 0 // minBal: uint64
	frame_dig -7 // globalBytes: uint64
	intc 14 // 50000
	*
	+
	frame_bury 0 // minBal: uint64

	// contracts\CaelusAdmin.algo.ts:801
	// return minBal;
	frame_dig 0 // minBal: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd220832d // method "creatorChangeCreatorRelatedParams(address,uint64,uint64)void"
	pushbytes 0x33e463e5 // method "initPoolContract(uint64)void"
	pushbytes 0xc4f4ad20 // method "writePoolContractProgram(uint64,byte[])void"
	pushbytes 0x9e2ef197 // method "updatePoolContract(uint64)void"
	pushbytes 0x124a9e30 // method "initLST(string,string,string)void"
	pushbytes 0x1f0ebf5f // method "initBurnQueue()void"
	pushbytes 0x1263175a // method "addCaelusValidator(pay)void"
	pushbytes 0x69035a1c // method "calculateLSTRatio()void"
	pushbytes 0x8b874f1d // method "getMintAmount(uint64)uint64"
	pushbytes 0x373465d7 // method "getBurnAmount(uint64)uint64"
	pushbytes 0x03178883 // method "delayedMintRequest(pay)void"
	pushbytes 0x0179c1d2 // method "claimMint()void"
	pushbytes 0xc731d519 // method "instantMintRequest(pay)void"
	pushbytes 0xe7a75417 // method "getPremiumAmount(uint64)uint64"
	pushbytes 0x519abfa0 // method "burnRequest(axfer,address)void"
	pushbytes 0xe5747e07 // method "mintValidatorCommit(uint64,pay)void"
	pushbytes 0xefdf88d1 // method "burnValidatorCommit(uint64,axfer)void"
	pushbytes 0xb13cc0b1 // method "burnToDelinquentValidator(axfer,uint64)void"
	pushbytes 0xb1d68139 // method "reMintDeliquentCommit(uint64,uint64)void"
	pushbytes 0xeddfe598 // method "bid(uint64)void"
	pushbytes 0xe45c40e0 // method "delegateStake(uint64,uint64)void"
	pushbytes 0x31756a95 // method "snitchToBurn(uint64)void"
	pushbytes 0x66599703 // method "multiSnitchToBurn(uint64[])void"
	pushbytes 0x911c3c46 // method "reStakeFromSnitch(uint64,uint64,pay)void"
	pushbytes 0x5e073e67 // method "onOperatorExit(uint64,pay)void"
	pushbytes 0xefa32849 // method "declareRewards(pay,uint64)void"
	pushbytes 0xd2be586a // method "snitchCheck(uint64,(bool,bool,bool,uint64,bool,uint64))bool"
	pushbytes 0x8bfa1157 // method "makeFlashLoanRequest(pay,uint64[],uint64[])void"
	pushbytes 0x7c941b35 // method "getFLcounter()uint64"
	txna ApplicationArgs 0
	match *abi_route_creatorChangeCreatorRelatedParams *abi_route_initPoolContract *abi_route_writePoolContractProgram *abi_route_updatePoolContract *abi_route_initLST *abi_route_initBurnQueue *abi_route_addCaelusValidator *abi_route_calculateLSTRatio *abi_route_getMintAmount *abi_route_getBurnAmount *abi_route_delayedMintRequest *abi_route_claimMint *abi_route_instantMintRequest *abi_route_getPremiumAmount *abi_route_burnRequest *abi_route_mintValidatorCommit *abi_route_burnValidatorCommit *abi_route_burnToDelinquentValidator *abi_route_reMintDeliquentCommit *abi_route_bid *abi_route_delegateStake *abi_route_snitchToBurn *abi_route_multiSnitchToBurn *abi_route_reStakeFromSnitch *abi_route_onOperatorExit *abi_route_declareRewards *abi_route_snitchCheck *abi_route_makeFlashLoanRequest *abi_route_getFLcounter

	// this contract does not implement the given ABI method for call NoOp
	err

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub