#pragma version 11
intcblock 0 1 2 50000000000000 6 32 1000 5
bytecblock 0x 0x6f70657261746f72436f6d6d6974 0x6d6178445374616b65 0x00 0x64656c696e7175656e637953636f7265 0x63616e426544656c656761746564 0x6f70657261746f72 0x64656c6567617465645374616b65 0x697344656c696e7175656e74 0x706572666f726d616e6365 0x64656c696e7175656e63795265706f7274 0x73617475726174696f6e427566666572 0x7265776172645265706f7274 0x63726561746f72 0x766573744944

// This TEAL was generated by TEALScript v0.105.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 4 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *call_CloseOut *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64,address,uint64,address,uint64,uint64)void
*abi_route_createApplication:
	// stVestID: uint64
	txna ApplicationArgs 6
	btoi

	// vestID: uint64
	txna ApplicationArgs 5
	btoi

	// xGovVotingAddress: address
	txna ApplicationArgs 4
	dup
	len
	intc 5 // 32
	==

	// argument 2 (xGovVotingAddress) for createApplication must be a address
	assert

	// contractVersion: uint64
	txna ApplicationArgs 3
	btoi

	// operatorAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 5 // 32
	==

	// argument 4 (operatorAddress) for createApplication must be a address
	assert

	// creatingContract: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,address,uint64,address,uint64,uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(creatingContract: AppID, operatorAddress: Address, contractVersion: uint64, xGovVotingAddress: Address, vestID: AssetID, stVestID: AssetID): void
//
// ******************
// Public Methods    *
// ******************
//
// createApplication method called at creation, initializes some globalKey values
// @param {AppID} creatingContract - ApplicationID for the creator contract (CaelusAdminContract)
// @param {Address} operatorAddress - Address of the node operator used to sign online/offline txns and participate in auctions
// @param {uint64} contractVersion - Approval Program version for the node contract, stored in the CaelusAdminContract
createApplication:
	proto 6 0

	// contracts\CaelusValidator.algo.ts:70
	// this.creatorContractAppID.value = creatingContract
	bytec 13 //  "creator"
	frame_dig -1 // creatingContract: AppID
	app_global_put

	// contracts\CaelusValidator.algo.ts:71
	// this.operatorAddress.value = operatorAddress
	bytec 6 //  "operator"
	frame_dig -2 // operatorAddress: Address
	app_global_put

	// contracts\CaelusValidator.algo.ts:72
	// this.validatorPoolContractVersion.value = contractVersion
	pushbytes 0x636f6e747261637456657273696f6e // "contractVersion"
	frame_dig -3 // contractVersion: uint64
	app_global_put

	// contracts\CaelusValidator.algo.ts:73
	// this.xGovVotingAddress.value = xGovVotingAddress
	pushbytes 0x78476f76566f746572 // "xGovVoter"
	frame_dig -4 // xGovVotingAddress: Address
	app_global_put

	// contracts\CaelusValidator.algo.ts:74
	// this.vestID.value = vestID
	bytec 14 //  "vestID"
	frame_dig -5 // vestID: AssetID
	app_global_put

	// contracts\CaelusValidator.algo.ts:75
	// this.stVestID.value = stVestID
	pushbytes 0x7374566573744944 // "stVestID"
	frame_dig -6 // stVestID: AssetID
	app_global_put

	// contracts\CaelusValidator.algo.ts:78
	// this.operatorCommit.value = 0
	bytec 1 //  "operatorCommit"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:79
	// this.delegatedStake.value = 0
	bytec 7 //  "delegatedStake"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:80
	// this.maxDelegatableStake.value = 0
	bytec 2 //  "maxDStake"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:81
	// this.canBeDelegated.value = false
	bytec 5 //  "canBeDelegated"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusValidator.algo.ts:84
	// this.saturationBUFFER.value = 0
	bytec 11 //  "saturationBuffer"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:85
	// this.performanceCounter.value = 0
	bytec 9 //  "performance"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:86
	// this.delinquencyScore.value = 0
	bytec 4 //  "delinquencyScore"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:87
	// this.isDelinquent.value = false
	bytec 8 //  "isDelinquent"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// addToOperatorCommit(pay)void
*abi_route_addToOperatorCommit:
	// commit: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (commit) for addToOperatorCommit must be a pay transaction
	assert

	// execute addToOperatorCommit(pay)void
	callsub addToOperatorCommit
	intc 1 // 1
	return

// addToOperatorCommit(commit: PayTxn): void
//
// Used by the node operator to add to his stake amount for the node
//
// @param {PayTxn} commit - node operator stake commitment
// @throws {Error} if the sender isn't the node operator, the receiver isn't the app address or if the total balance is above 30M Algo
addToOperatorCommit:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusValidator.algo.ts:98
	// totalBalanceUpdated = this.operatorCommit.value + commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	frame_bury 0 // totalBalanceUpdated: uint64

	// contracts\CaelusValidator.algo.ts:99
	// assert(totalBalanceUpdated < globals.payoutsMaxBalance, 'Contract max balance cannot be over 30M Algo')
	frame_dig 0 // totalBalanceUpdated: uint64
	global PayoutsMaxBalance
	<

	// Contract max balance cannot be over 30M Algo
	assert

	// contracts\CaelusValidator.algo.ts:101
	// verifyPayTxn(commit, {
	//       sender: this.operatorAddress.value,
	//       receiver: this.app.address,
	//       amount: commit.amount,
	//     })
	// verify sender
	frame_dig -1 // commit: PayTxn
	gtxns Sender
	bytec 6 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"commit","field":"sender","expected":"this.operatorAddress.value"}
	assert

	// verify receiver
	frame_dig -1 // commit: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"commit","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	==

	// transaction verification failed: {"txn":"commit","field":"amount","expected":"commit.amount"}
	assert

	// contracts\CaelusValidator.algo.ts:106
	// this.operatorCommit.value += commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	bytec 1 //  "operatorCommit"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:107
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// removeFromOperatorCommit(uint64)void
*abi_route_removeFromOperatorCommit:
	// claimRequest: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeFromOperatorCommit(uint64)void
	callsub removeFromOperatorCommit
	intc 1 // 1
	return

// removeFromOperatorCommit(claimRequest: uint64): void
//
// Used by the node operator to remove from his stake amount for the node
// @param {uint64} claimRequest - amount claimed by the node operator to be removed from the contract balance and subtracted from the operator_commit counter
// @throws {Error} if the sender isn't the node operator or if the total commit by the node operator goes below the min threshold for rewards eligibility
// @throws {Error} if isDelinquent is True
removeFromOperatorCommit:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:118
	// assert(!this.isDelinquent.value, 'cannot withdraw funds if the account is flagged as delinquent, must solve delinquency first')
	bytec 8 //  "isDelinquent"
	app_global_get
	intc 0 // 0
	getbit
	!

	// cannot withdraw funds if the account is flagged as delinquent, must solve delinquency first
	assert

	// contracts\CaelusValidator.algo.ts:120
	// assert(this.txn.sender === this.operatorAddress.value, 'Only the Node Operator can claim his stake')
	txn Sender
	bytec 6 //  "operator"
	app_global_get
	==

	// Only the Node Operator can claim his stake
	assert

	// contracts\CaelusValidator.algo.ts:122
	// assert(
	//       this.operatorCommit.value - claimRequest > globals.payoutsMinBalance,
	//       'Node Operator can take his stake below 30k only if the node contract will be closed'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // claimRequest: uint64
	-
	global PayoutsMinBalance
	>

	// Node Operator can take his stake below 30k only if the node contract will be closed
	assert

	// contracts\CaelusValidator.algo.ts:127
	// assert(
	//       this.operatorCommit.value > claimRequest, 'Node Operator cannot claim more than he has'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // claimRequest: uint64
	>

	// Node Operator cannot claim more than he has
	assert

	// contracts\CaelusValidator.algo.ts:131
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.operatorAddress.value,
	//       amount: claimRequest,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:132
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts\CaelusValidator.algo.ts:133
	// receiver: this.operatorAddress.value
	bytec 6 //  "operator"
	app_global_get
	itxn_field Receiver

	// contracts\CaelusValidator.algo.ts:134
	// amount: claimRequest
	frame_dig -1 // claimRequest: uint64
	itxn_field Amount

	// contracts\CaelusValidator.algo.ts:135
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusValidator.algo.ts:138
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// performanceCheck()void
*abi_route_performanceCheck:
	// execute performanceCheck()void
	callsub performanceCheck
	intc 1 // 1
	return

// performanceCheck(): void
performanceCheck:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// *if0_condition
	// contracts\CaelusValidator.algo.ts:145
	// !this.app.address.incentiveEligible
	global CurrentApplicationAddress
	acct_params_get AcctIncentiveEligible
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts\CaelusValidator.algo.ts:146
	// this.setDelinquency()
	callsub setDelinquency

*if0_end:
	// contracts\CaelusValidator.algo.ts:149
	// assert(globals.round - this.lastDelinquencyReport.value > this.getExpectedProposalsDelta(), 'Wait at least one ProposalsDelta between Performance checks')
	global Round
	bytec 10 //  "delinquencyReport"
	app_global_get
	-
	callsub getExpectedProposalsDelta
	>

	// Wait at least one ProposalsDelta between Performance checks
	assert

	// contracts\CaelusValidator.algo.ts:150
	// deltaWithLatestProposal = globals.round - this.app.address.lastProposed
	global Round
	global CurrentApplicationAddress
	acct_params_get AcctLastProposed
	pop
	-
	frame_bury 0 // deltaWithLatestProposal: uint64

	// contracts\CaelusValidator.algo.ts:152
	// isPerformingAsExpected = this.getExpectedProposalsDelta() > deltaWithLatestProposal
	callsub getExpectedProposalsDelta
	frame_dig 0 // deltaWithLatestProposal: uint64
	>
	frame_bury 1 // isPerformingAsExpected: bool

	// contracts\CaelusValidator.algo.ts:153
	// isPerformingAsTolerated = this.getToleratedBlockDelta() > deltaWithLatestProposal
	callsub getToleratedBlockDelta
	frame_dig 0 // deltaWithLatestProposal: uint64
	>
	frame_bury 2 // isPerformingAsTolerated: bool

	// *if1_condition
	// contracts\CaelusValidator.algo.ts:155
	// isPerformingAsExpected && isPerformingAsTolerated
	frame_dig 1 // isPerformingAsExpected: bool
	dup
	bz *skip_and0
	frame_dig 2 // isPerformingAsTolerated: bool
	&&

*skip_and0:
	bz *if1_end

	// *if1_consequent
	// contracts\CaelusValidator.algo.ts:156
	// return
	retsub

*if1_end:
	// *if2_condition
	// contracts\CaelusValidator.algo.ts:158
	// !isPerformingAsExpected && this.app.address.lastHeartbeat < globals.round - this.getExpectedProposalsDelta()
	frame_dig 1 // isPerformingAsExpected: bool
	!
	dup
	bz *skip_and1
	global CurrentApplicationAddress
	acct_params_get AcctLastHeartbeat
	pop
	global Round
	callsub getExpectedProposalsDelta
	-
	<
	&&

*skip_and1:
	bz *if2_end

	// *if2_consequent
	// contracts\CaelusValidator.algo.ts:159
	// this.performanceCounter.value = this.performanceCounter.value > 0 ? this.delinquencyScore.value += 1 : 0
	bytec 9 //  "performance"
	dup
	app_global_get
	intc 0 // 0
	>
	bz *ternary0_false
	bytec 4 //  "delinquencyScore"
	app_global_get
	intc 1 // 1
	+
	dup
	store 245 // assignment value
	bytec 4 //  "delinquencyScore"
	swap
	app_global_put
	load 245 // assignment value
	b *ternary0_end

*ternary0_false:
	intc 0 // 0

*ternary0_end:
	app_global_put

*if2_end:
	// *if3_condition
	// contracts\CaelusValidator.algo.ts:161
	// !isPerformingAsTolerated
	frame_dig 2 // isPerformingAsTolerated: bool
	!
	bz *if3_end

	// *if3_consequent
	// contracts\CaelusValidator.algo.ts:162
	// this.delinquencyScore.value += 4
	bytec 4 //  "delinquencyScore"
	app_global_get
	pushint 4
	+
	bytec 4 //  "delinquencyScore"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:163
	// this.setDelinquencyOnThresholdCheck()
	callsub setDelinquencyOnThresholdCheck

*if3_end:
	// contracts\CaelusValidator.algo.ts:165
	// this.lastDelinquencyReport.value = globals.round
	bytec 10 //  "delinquencyReport"
	global Round
	app_global_put
	retsub

// solveDelinquency()void
*abi_route_solveDelinquency:
	// execute solveDelinquency()void
	callsub solveDelinquency
	intc 1 // 1
	return

// solveDelinquency(): void
solveDelinquency:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:170
	// assert(this.isDelinquent.value, 'Account is not delinquent')
	bytec 8 //  "isDelinquent"
	app_global_get
	intc 0 // 0
	getbit

	// Account is not delinquent
	assert

	// contracts\CaelusValidator.algo.ts:171
	// assert(this.txn.sender === this.operatorAddress.value, 'Only the Node Operator can clear up Delinquency')
	txn Sender
	bytec 6 //  "operator"
	app_global_get
	==

	// Only the Node Operator can clear up Delinquency
	assert

	// contracts\CaelusValidator.algo.ts:172
	// assert(this.delegatedStake.value == 0, 'Before clearing up delinquency all the delegated stake must be redistributed')
	bytec 7 //  "delegatedStake"
	app_global_get
	intc 0 // 0
	==

	// Before clearing up delinquency all the delegated stake must be redistributed
	assert

	// contracts\CaelusValidator.algo.ts:173
	// assert(this.lastDelinquencyReport.value < this.lastRewardReport.value)
	bytec 10 //  "delinquencyReport"
	app_global_get
	bytec 12 //  "rewardReport"
	app_global_get
	<
	assert

	// contracts\CaelusValidator.algo.ts:174
	// assert(this.delinquencyThresholdCheck(), 'Delinquency score must be below threshold')
	callsub delinquencyThresholdCheck

	// Delinquency score must be below threshold
	assert

	// contracts\CaelusValidator.algo.ts:175
	// this.isDelinquent.value = false
	bytec 8 //  "isDelinquent"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusValidator.algo.ts:176
	// this.canBeDelegated.value = true
	bytec 5 //  "canBeDelegated"
	intc 1 // 1
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// reportRewards(uint64)void
*abi_route_reportRewards:
	// block: uint64
	txna ApplicationArgs 1
	btoi

	// execute reportRewards(uint64)void
	callsub reportRewards
	intc 1 // 1
	return

// reportRewards(block: uint64): void
reportRewards:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts\CaelusValidator.algo.ts:182
	// isOperatorReportTime = globals.round - block < 700
	global Round
	frame_dig -1 // block: uint64
	-
	pushint 700
	<
	frame_bury 0 // isOperatorReportTime: bool

	// contracts\CaelusValidator.algo.ts:183
	// report = blocks[block].proposerPayout
	frame_dig -1 // block: uint64
	block BlkProposerPayout
	frame_bury 1 // report: uint64

	// contracts\CaelusValidator.algo.ts:184
	// takeFee = (report * 6) / 100
	frame_dig 1 // report: uint64
	intc 4 // 6
	*
	pushint 100
	/
	frame_bury 2 // takeFee: uint64

	// *if4_condition
	// contracts\CaelusValidator.algo.ts:188
	// this.getExpectedProposalsDelta() < (globals.round - this.lastRewardReport.value)
	callsub getExpectedProposalsDelta
	global Round
	bytec 12 //  "rewardReport"
	app_global_get
	-
	<
	bz *if4_end

	// *if4_consequent
	// contracts\CaelusValidator.algo.ts:189
	// this.performanceCounter.value += 1
	bytec 9 //  "performance"
	app_global_get
	intc 1 // 1
	+
	bytec 9 //  "performance"
	swap
	app_global_put

*if4_end:
	// contracts\CaelusValidator.algo.ts:191
	// this.fixDelinquencyScore()
	callsub fixDelinquencyScore

	// contracts\CaelusValidator.algo.ts:192
	// this.lastRewardReport.value = block
	bytec 12 //  "rewardReport"
	frame_dig -1 // block: uint64
	app_global_put

	// *if5_condition
	// contracts\CaelusValidator.algo.ts:193
	// isOperatorReportTime
	frame_dig 0 // isOperatorReportTime: bool
	bz *if5_else

	// *if5_consequent
	// contracts\CaelusValidator.algo.ts:194
	// this.operatorCommit.value += takeFee
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig 2 // takeFee: uint64
	+
	bytec 1 //  "operatorCommit"
	swap
	app_global_put
	b *if5_end

*if5_else:
	// contracts\CaelusValidator.algo.ts:196
	// snitched = takeFee / 2
	frame_dig 2 // takeFee: uint64
	intc 2 // 2
	/
	frame_bury 3 // snitched: uint64

	// contracts\CaelusValidator.algo.ts:197
	// opKeeps = takeFee - snitched
	frame_dig 2 // takeFee: uint64
	frame_dig 3 // snitched: uint64
	-
	frame_bury 4 // opKeeps: uint64

	// contracts\CaelusValidator.algo.ts:198
	// this.operatorCommit.value += opKeeps
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig 4 // opKeeps: uint64
	+
	bytec 1 //  "operatorCommit"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:199
	// sendPayment({
	//         receiver: this.txn.sender,
	//         amount: snitched,
	//         fee: 0
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:200
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts\CaelusValidator.algo.ts:201
	// amount: snitched
	frame_dig 3 // snitched: uint64
	itxn_field Amount

	// contracts\CaelusValidator.algo.ts:202
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	// contracts\CaelusValidator.algo.ts:205
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// issueBid()void
*abi_route_issueBid:
	// execute issueBid()void
	callsub issueBid
	intc 1 // 1
	return

// issueBid(): void
issueBid:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:210
	// assert(this.canBeDelegated.value, 'Account cannot take more delegated stake')
	bytec 5 //  "canBeDelegated"
	app_global_get
	intc 0 // 0
	getbit

	// Account cannot take more delegated stake
	assert

	// contracts\CaelusValidator.algo.ts:212
	// sendMethodCall<typeof CaelusAdmin.prototype.bid>({
	//
	//     })
	itxn_begin
	intc 4 //  appl
	itxn_field TypeEnum
	pushbytes 0xeddfe598 // method "bid(uint64)void"
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// takeStakeRequest(uint64)void
*abi_route_takeStakeRequest:
	// amount: uint64
	txna ApplicationArgs 1
	btoi

	// execute takeStakeRequest(uint64)void
	callsub takeStakeRequest
	intc 1 // 1
	return

// takeStakeRequest(amount: uint64): void
takeStakeRequest:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:218
	// assert(this.canBeDelegated.value, 'Account cannot take more delegated stake')
	bytec 5 //  "canBeDelegated"
	app_global_get
	intc 0 // 0
	getbit

	// Account cannot take more delegated stake
	assert
	retsub

// addStake(pay)void
*abi_route_addStake:
	// txnWithStake: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 0 (txnWithStake) for addStake must be a pay transaction
	assert

	// execute addStake(pay)void
	callsub addStake
	intc 1 // 1
	return

// addStake(txnWithStake: PayTxn): void
addStake:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:224
	// verifyPayTxn(txnWithStake, {
	//       receiver: this.app.address
	//     })
	// verify receiver
	frame_dig -1 // txnWithStake: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"txnWithStake","field":"receiver","expected":"this.app.address"}
	assert

	// contracts\CaelusValidator.algo.ts:227
	// this.delegatedStake.value += txnWithStake.amount
	bytec 7 //  "delegatedStake"
	app_global_get
	frame_dig -1 // txnWithStake: PayTxn
	gtxns Amount
	+
	bytec 7 //  "delegatedStake"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:228
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// burnStake(uint64,address)void
*abi_route_burnStake:
	// receiverBurn: address
	txna ApplicationArgs 2
	dup
	len
	intc 5 // 32
	==

	// argument 0 (receiverBurn) for burnStake must be a address
	assert

	// amountRequested: uint64
	txna ApplicationArgs 1
	btoi

	// execute burnStake(uint64,address)void
	callsub burnStake
	intc 1 // 1
	return

// burnStake(amountRequested: uint64, receiverBurn: Address): void
burnStake:
	proto 2 0

	// contracts\CaelusValidator.algo.ts:233
	// assert(this.txn.sender === this.creatorContractAppID.value.address, 'Only the Caelus Admin contract can call this method')
	txn Sender
	bytec 13 //  "creator"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// Only the Caelus Admin contract can call this method
	assert

	// contracts\CaelusValidator.algo.ts:234
	// assert(amountRequested <= this.delegatedStake.value, 'Cannot withdraw more stake than the delegated amount')
	frame_dig -1 // amountRequested: uint64
	bytec 7 //  "delegatedStake"
	app_global_get
	<=

	// Cannot withdraw more stake than the delegated amount
	assert

	// contracts\CaelusValidator.algo.ts:235
	// sendPayment({
	//       amount: amountRequested,
	//       receiver: receiverBurn,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:236
	// amount: amountRequested
	frame_dig -1 // amountRequested: uint64
	itxn_field Amount

	// contracts\CaelusValidator.algo.ts:237
	// receiver: receiverBurn
	frame_dig -2 // receiverBurn: Address
	itxn_field Receiver

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusValidator.algo.ts:239
	// this.delegatedStake.value -= amountRequested
	bytec 7 //  "delegatedStake"
	app_global_get
	frame_dig -1 // amountRequested: uint64
	-
	bytec 7 //  "delegatedStake"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:240
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// snitchBurn()void
*abi_route_snitchBurn:
	// execute snitchBurn()void
	callsub snitchBurn
	intc 1 // 1
	return

// snitchBurn(): void
snitchBurn:
	proto 0 0
	retsub

// issueSnitch()void
*abi_route_issueSnitch:
	// execute issueSnitch()void
	callsub issueSnitch
	intc 1 // 1
	return

// issueSnitch(): void
issueSnitch:
	proto 0 0
	retsub

// getSnitched()void
*abi_route_getSnitched:
	// execute getSnitched()void
	callsub getSnitched
	intc 1 // 1
	return

// getSnitched(): void
getSnitched:
	proto 0 0
	retsub

// clawbackStake()void
*abi_route_clawbackStake:
	// execute clawbackStake()void
	callsub clawbackStake
	intc 1 // 1
	return

// clawbackStake(): void
clawbackStake:
	proto 0 0
	retsub

// clawbackStakeToValidator()void
*abi_route_clawbackStakeToValidator:
	// execute clawbackStakeToValidator()void
	callsub clawbackStakeToValidator
	intc 1 // 1
	return

// clawbackStakeToValidator(): void
clawbackStakeToValidator:
	proto 0 0
	retsub

// upgradeToNewValidatorVersion()void
*abi_route_upgradeToNewValidatorVersion:
	// execute upgradeToNewValidatorVersion()void
	callsub upgradeToNewValidatorVersion
	intc 1 // 1
	return

// upgradeToNewValidatorVersion(): void
upgradeToNewValidatorVersion:
	proto 0 0
	retsub

// flashloan()void
*abi_route_flashloan:
	// execute flashloan()void
	callsub flashloan
	intc 1 // 1
	return

// flashloan(): void
flashloan:
	proto 0 0
	retsub

// claimLeftAlgo()void
*abi_route_claimLeftAlgo:
	// execute claimLeftAlgo()void
	callsub claimLeftAlgo
	intc 1 // 1
	return

// claimLeftAlgo(): void
claimLeftAlgo:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:266
	// assert(this.app.address.voterBalance == 0, 'Account Stake must be offline')
	global CurrentApplicationAddress
	voter_params_get VoterBalance
	intc 0 // 0
	==

	// Account Stake must be offline
	assert

	// contracts\CaelusValidator.algo.ts:267
	// assert(this.delegatedStake.value == 0, 'All delegated Stake must have been removed')
	bytec 7 //  "delegatedStake"
	app_global_get
	intc 0 // 0
	==

	// All delegated Stake must have been removed
	assert

	// contracts\CaelusValidator.algo.ts:268
	// assert(this.operatorCommit.value == 0, 'Node Operator must have withdrawn his commitment')
	bytec 1 //  "operatorCommit"
	app_global_get
	intc 0 // 0
	==

	// Node Operator must have withdrawn his commitment
	assert
	retsub

// operatorExit()void
*abi_route_operatorExit:
	// execute operatorExit()void
	callsub operatorExit
	intc 1 // 1
	return

// operatorExit(): void
operatorExit:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:281
	// assert(this.app.address.voterBalance === 0, 'Account is online, sign it offline before exiting')
	global CurrentApplicationAddress
	voter_params_get VoterBalance
	intc 0 // 0
	==

	// Account is online, sign it offline before exiting
	assert

	// contracts\CaelusValidator.algo.ts:282
	// assert(this.txn.sender === this.operatorAddress.value, 'Only the Node Operator can issue this transaction')
	txn Sender
	bytec 6 //  "operator"
	app_global_get
	==

	// Only the Node Operator can issue this transaction
	assert
	retsub

// closeOutOfApplication(any[])void
*abi_route_closeOutOfApplication:
	// args: any[]
	txna ApplicationArgs 1
	extract 2 0

	// execute closeOutOfApplication(any[])void
	callsub closeOutOfApplication
	intc 1 // 1
	return

// closeOutOfApplication(...args: any[]): void
closeOutOfApplication:
	proto 1 0
	retsub

// goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub goOnline
	intc 1 // 1
	return

// goOnline(feePayment: PayTxn, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// Used to set the Contract account online for consensus. Always check that account is online and incentivesEligible before having delegatable stake
//
// @param {PayTxn} feePayment - Payment transaction to the contract to cover costs for Eligibility fee 0 for renewal.
// @param {bytes} votePK - The vote public key
// @param {bytes} selectionPK - The selection public key
// @param {bytes} stateProofPK - the state proof public key
// @param {uint64} voteFirst - Index of first valid block for the participation keys
// @param {uint64} voteLast - Index of last valid block for for the participation keys
// @param {uint64} voteKeyDilution - The vote key dilution value
// @throws {Error} if the caller isn't the node operator
// @throws {Error} if isDelinquent is True
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusValidator.algo.ts:313
	// assert(
	//       this.txn.sender === this.operatorAddress.value,
	//       'Only the Node Operator can register online with participation key'
	//     )
	txn Sender
	bytec 6 //  "operator"
	app_global_get
	==

	// Only the Node Operator can register online with participation key
	assert

	// contracts\CaelusValidator.algo.ts:319
	// assert(
	//       this.app.address.balance >= globals.payoutsMinBalance && this.app.address.balance <= MAX_STAKE_PER_ACCOUNT,
	//       'Contract needs 30k Algo as minimum balance for rewards eligibility and at most 50M Algo'
	//     )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global PayoutsMinBalance
	>=
	dup
	bz *skip_and2
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 3 // 50000000000000
	<=
	&&

*skip_and2:
	// Contract needs 30k Algo as minimum balance for rewards eligibility and at most 50M Algo
	assert

	// contracts\CaelusValidator.algo.ts:325
	// assert(
	//       this.operatorCommit.value >= globals.payoutsMinBalance,
	//       'Operator commit must be higher than minimum balance for rewards eligibility'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	global PayoutsMinBalance
	>=

	// Operator commit must be higher than minimum balance for rewards eligibility
	assert

	// contracts\CaelusValidator.algo.ts:329
	// extraFee = this.getGoOnlineFeeAmount()
	callsub getGoOnlineFeeAmount
	frame_bury 0 // extraFee: uint64

	// contracts\CaelusValidator.algo.ts:331
	// verifyPayTxn(feePayment, { receiver: this.app.address, amount: extraFee })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// contracts\CaelusValidator.algo.ts:333
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	intc 2 //  keyreg
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:334
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts\CaelusValidator.algo.ts:335
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts\CaelusValidator.algo.ts:336
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts\CaelusValidator.algo.ts:337
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\CaelusValidator.algo.ts:338
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\CaelusValidator.algo.ts:339
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\CaelusValidator.algo.ts:340
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusValidator.algo.ts:342
	// this.canBeDelegated.value = true
	bytec 5 //  "canBeDelegated"
	intc 1 // 1
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// goOffline()void
*abi_route_goOffline:
	// execute goOffline()void
	callsub goOffline
	intc 1 // 1
	return

// goOffline(): void
//
// Set the contract account to offline so that it doesn't participate in consensus anymore.
// No force offline by the protocol. Lookup Delinquency status
// Once the account is set offline the method ensures that it cannot be delegated to.
goOffline:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:353
	// assert(
	//       this.txn.sender === this.operatorAddress.value || this.txn.sender === this.creatorContractAppID.value.address,
	//       'Only Node Operator or Caelus Admin contract can set the contract offline'
	//     )
	txn Sender
	bytec 6 //  "operator"
	app_global_get
	==
	dup
	bnz *skip_or0
	txn Sender
	bytec 13 //  "creator"
	app_global_get
	app_params_get AppAddress
	pop
	==
	||

*skip_or0:
	// Only Node Operator or Caelus Admin contract can set the contract offline
	assert

	// contracts\CaelusValidator.algo.ts:357
	// this.canBeDelegated.value = false
	bytec 5 //  "canBeDelegated"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusValidator.algo.ts:358
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 2 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getGoOnlineFeeAmount(): uint64
//
// *****************
// Private Methods  *
// *****************
getGoOnlineFeeAmount:
	proto 0 1

	// *if6_condition
	// contracts\CaelusValidator.algo.ts:368
	// !this.getEligibilityFlag()
	callsub getEligibilityFlag
	!
	bz *if6_end

	// *if6_consequent
	// contracts\CaelusValidator.algo.ts:369
	// return globals.payoutsGoOnlineFee
	global PayoutsGoOnlineFee
	retsub

*if6_end:
	// contracts\CaelusValidator.algo.ts:371
	// return 0
	intc 0 // 0
	retsub

// getEligibilityFlag()bool
*abi_route_getEligibilityFlag:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getEligibilityFlag()bool
	callsub getEligibilityFlag
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// getEligibilityFlag(): boolean
getEligibilityFlag:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:376
	// return this.app.address.incentiveEligible
	global CurrentApplicationAddress
	acct_params_get AcctIncentiveEligible
	pop
	retsub

// setDelinquencyOnThresholdCheck(): void
setDelinquencyOnThresholdCheck:
	proto 0 0

	// *if7_condition
	// contracts\CaelusValidator.algo.ts:380
	// !this.delinquencyThresholdCheck()
	callsub delinquencyThresholdCheck
	!
	bz *if7_end

	// *if7_consequent
	// contracts\CaelusValidator.algo.ts:381
	// this.setDelinquency()
	callsub setDelinquency

*if7_end:
	retsub

// delinquencyThresholdCheck(): boolean
delinquencyThresholdCheck:
	proto 0 1

	// *if8_condition
	// contracts\CaelusValidator.algo.ts:386
	// this.delinquencyScore.value > MAX_DELINQUENCY_TOLERATED
	bytec 4 //  "delinquencyScore"
	app_global_get
	pushint 20
	>
	bz *if8_end

	// *if8_consequent
	// contracts\CaelusValidator.algo.ts:387
	// return false
	intc 0 // 0
	retsub

*if8_end:
	// contracts\CaelusValidator.algo.ts:389
	// return true
	intc 1 // 1
	retsub

// setDelinquency(): void
setDelinquency:
	proto 0 0

	// contracts\CaelusValidator.algo.ts:393
	// this.canBeDelegated.value = false
	bytec 5 //  "canBeDelegated"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts\CaelusValidator.algo.ts:394
	// this.performanceCounter.value = 0
	bytec 9 //  "performance"
	intc 0 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:395
	// this.updateDelegationFactors()
	callsub updateDelegationFactors

	// contracts\CaelusValidator.algo.ts:396
	// this.isDelinquent.value = true
	bytec 8 //  "isDelinquent"
	intc 1 // 1
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// fixDelinquencyScore(): void
fixDelinquencyScore:
	proto 0 0

	// *if9_condition
	// contracts\CaelusValidator.algo.ts:400
	// this.delinquencyScore.value == 0
	bytec 4 //  "delinquencyScore"
	app_global_get
	intc 0 // 0
	==
	bz *if9_end

	// *if9_consequent
	// contracts\CaelusValidator.algo.ts:401
	// return
	retsub

*if9_end:
	// *if10_condition
	// contracts\CaelusValidator.algo.ts:404
	// this.isDelinquent.value
	bytec 8 //  "isDelinquent"
	app_global_get
	intc 0 // 0
	getbit
	bz *if10_end

	// *if10_consequent
	// contracts\CaelusValidator.algo.ts:405
	// this.delinquencyScore.value -= 5
	bytec 4 //  "delinquencyScore"
	app_global_get
	intc 7 // 5
	-
	bytec 4 //  "delinquencyScore"
	swap
	app_global_put

*if10_end:
	// contracts\CaelusValidator.algo.ts:407
	// this.delinquencyScore.value = 0
	bytec 4 //  "delinquencyScore"
	intc 0 // 0
	app_global_put
	retsub

// updateDelegationFactors(): void
updateDelegationFactors:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts\CaelusValidator.algo.ts:411
	// assert(!this.isDelinquent.value, 'Account is delinquent. Solve Delinquency state before updating parameters')
	bytec 8 //  "isDelinquent"
	app_global_get
	intc 0 // 0
	getbit
	!

	// Account is delinquent. Solve Delinquency state before updating parameters
	assert

	// *if11_condition
	// contracts\CaelusValidator.algo.ts:413
	// this.operatorCommit.value > globals.payoutsMinBalance && this.canBeDelegated.value
	bytec 1 //  "operatorCommit"
	app_global_get
	global PayoutsMinBalance
	>
	dup
	bz *skip_and3
	bytec 5 //  "canBeDelegated"
	app_global_get
	intc 0 // 0
	getbit
	&&

*skip_and3:
	bz *if11_else

	// *if11_consequent
	// contracts\CaelusValidator.algo.ts:414
	// this.maxDelegatableStake.value = this.operatorCommit.value
	bytec 2 //  "maxDStake"
	bytec 1 //  "operatorCommit"
	app_global_get
	app_global_put
	b *if11_end

*if11_else:
	// contracts\CaelusValidator.algo.ts:416
	// this.maxDelegatableStake.value = 0
	bytec 2 //  "maxDStake"
	intc 0 // 0
	app_global_put

*if11_end:
	// contracts\CaelusValidator.algo.ts:420
	// vestBoost = (this.getTierVEST() * this.operatorCommit.value) / 2
	callsub getTierVEST
	bytec 1 //  "operatorCommit"
	app_global_get
	*
	intc 2 // 2
	/
	frame_bury 0 // vestBoost: uint64

	// contracts\CaelusValidator.algo.ts:422
	// this.maxDelegatableStake.value += vestBoost
	bytec 2 //  "maxDStake"
	app_global_get
	frame_dig 0 // vestBoost: uint64
	+
	bytec 2 //  "maxDStake"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:425
	// this.maxDelegatableStake.value += PERFORMANCE_STAKE_INCREASE * (this.performanceCounter.value / PERFORMANCE_STEP)
	bytec 2 //  "maxDStake"
	app_global_get
	pushint 10000000000
	bytec 9 //  "performance"
	app_global_get
	intc 7 // 5
	/
	*
	+
	bytec 2 //  "maxDStake"
	swap
	app_global_put

	// *if12_condition
	// contracts\CaelusValidator.algo.ts:428
	// this.app.address.balance >= MAX_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 3 // 50000000000000
	>=
	bz *if12_elseif1_condition

	// *if12_consequent
	// contracts\CaelusValidator.algo.ts:429
	// this.maxDelegatableStake.value = 0
	bytec 2 //  "maxDStake"
	intc 0 // 0
	app_global_put
	b *if12_end

*if12_elseif1_condition:
	// contracts\CaelusValidator.algo.ts:430
	// this.app.address.balance + this.maxDelegatableStake.value > MAX_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 2 //  "maxDStake"
	app_global_get
	+
	intc 3 // 50000000000000
	>
	bz *if12_end

	// *if12_elseif1_consequent
	// contracts\CaelusValidator.algo.ts:431
	// this.maxDelegatableStake.value =
	//         MAX_STAKE_PER_ACCOUNT- this.app.address.balance
	bytec 2 //  "maxDStake"
	intc 3 // 50000000000000
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	-
	app_global_put

*if12_end:
	// *if13_condition
	// contracts\CaelusValidator.algo.ts:436
	// this.maxDelegatableStake.value > 0
	bytec 2 //  "maxDStake"
	app_global_get
	intc 0 // 0
	>
	bz *if13_else

	// *if13_consequent
	// contracts\CaelusValidator.algo.ts:437
	// this.saturationBUFFER.value = (this.delegatedStake.value * 1000) / this.maxDelegatableStake.value
	bytec 11 //  "saturationBuffer"
	bytec 7 //  "delegatedStake"
	app_global_get
	intc 6 // 1000
	*
	bytec 2 //  "maxDStake"
	app_global_get
	/
	app_global_put

	// contracts\CaelusValidator.algo.ts:438
	// this.canBeDelegated.value = true
	bytec 5 //  "canBeDelegated"
	intc 1 // 1
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	b *if13_end

*if13_else:
	// contracts\CaelusValidator.algo.ts:440
	// this.saturationBUFFER.value = 1000
	bytec 11 //  "saturationBuffer"
	intc 6 // 1000
	app_global_put

	// contracts\CaelusValidator.algo.ts:441
	// this.canBeDelegated.value = false
	bytec 5 //  "canBeDelegated"
	intc 0 // 0
	bytec 3 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

*if13_end:
	retsub

// getTierVEST(): uint64
getTierVEST:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts\CaelusValidator.algo.ts:446
	// lockedVEST = this.operatorAddress.value.assetBalance(this.vestID.value)
	bytec 6 //  "operator"
	app_global_get
	bytec 14 //  "vestID"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // lockedVEST: uint64

	// contracts\CaelusValidator.algo.ts:447
	// ownedVEST = this.operatorAddress.value.assetBalance(this.vestID.value)
	bytec 6 //  "operator"
	app_global_get
	bytec 14 //  "vestID"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 1 // ownedVEST: uint64

	// *if14_condition
	// contracts\CaelusValidator.algo.ts:448
	// lockedVEST + ownedVEST >= VEST_TIER_5
	frame_dig 0 // lockedVEST: uint64
	frame_dig 1 // ownedVEST: uint64
	+
	pushint 150000000000
	>=
	bz *if14_end

	// *if14_consequent
	// contracts\CaelusValidator.algo.ts:449
	// return 2
	intc 2 // 2
	b *getTierVEST*return

*if14_end:
	// *if15_condition
	// contracts\CaelusValidator.algo.ts:451
	// lockedVEST + ownedVEST >= VEST_TIER_4
	frame_dig 0 // lockedVEST: uint64
	frame_dig 1 // ownedVEST: uint64
	+
	pushint 100000000000
	>=
	bz *if15_end

	// *if15_consequent
	// contracts\CaelusValidator.algo.ts:452
	// return 1
	intc 1 // 1
	b *getTierVEST*return

*if15_end:
	// contracts\CaelusValidator.algo.ts:454
	// return 0
	intc 0 // 0

*getTierVEST*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// getToleratedBlockDelta(): uint64
getToleratedBlockDelta:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:460
	// return this.getExpectedProposalsDelta() * 10
	callsub getExpectedProposalsDelta
	pushint 10
	*
	retsub

// getExpectedProposalsDelta(): uint64
getExpectedProposalsDelta:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts\CaelusValidator.algo.ts:465
	// currentOnlineStake = onlineStake()
	online_stake
	frame_bury 0 // currentOnlineStake: uint64

	// contracts\CaelusValidator.algo.ts:466
	// currentAccountStake = this.app.address.voterBalance
	global CurrentApplicationAddress
	voter_params_get VoterBalance
	frame_bury 1 // currentAccountStake: uint64

	// contracts\CaelusValidator.algo.ts:467
	// accountTotalStakeShare = currentAccountStake / currentOnlineStake
	frame_dig 1 // currentAccountStake: uint64
	frame_dig 0 // currentOnlineStake: uint64
	/
	frame_bury 2 // accountTotalStakeShare: uint64

	// contracts\CaelusValidator.algo.ts:469
	// return 0
	intc 0 // 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*create_NoOp:
	pushbytes 0x00d6bd3a // method "createApplication(uint64,address,uint64,address,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xdfa20764 // method "addToOperatorCommit(pay)void"
	pushbytes 0xf6786084 // method "removeFromOperatorCommit(uint64)void"
	pushbytes 0x7cffc787 // method "performanceCheck()void"
	pushbytes 0xce667431 // method "solveDelinquency()void"
	pushbytes 0x44a5b576 // method "reportRewards(uint64)void"
	pushbytes 0xf7908fe3 // method "issueBid()void"
	pushbytes 0xc29afa7b // method "takeStakeRequest(uint64)void"
	pushbytes 0xd4502100 // method "addStake(pay)void"
	pushbytes 0x3dc7ae79 // method "burnStake(uint64,address)void"
	pushbytes 0xfa3707b2 // method "snitchBurn()void"
	pushbytes 0x6e9c2cd6 // method "issueSnitch()void"
	pushbytes 0x94fad843 // method "getSnitched()void"
	pushbytes 0x54d05381 // method "clawbackStake()void"
	pushbytes 0xed0f417f // method "clawbackStakeToValidator()void"
	pushbytes 0x3f63cd8d // method "upgradeToNewValidatorVersion()void"
	pushbytes 0xcd48c5b6 // method "flashloan()void"
	pushbytes 0xa69ea4a7 // method "claimLeftAlgo()void"
	pushbytes 0xcdff10ea // method "operatorExit()void"
	pushbytes 0x400e14fb // method "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x51ef3b21 // method "goOffline()void"
	pushbytes 0xf9dc2646 // method "getEligibilityFlag()bool"
	txna ApplicationArgs 0
	match *abi_route_addToOperatorCommit *abi_route_removeFromOperatorCommit *abi_route_performanceCheck *abi_route_solveDelinquency *abi_route_reportRewards *abi_route_issueBid *abi_route_takeStakeRequest *abi_route_addStake *abi_route_burnStake *abi_route_snitchBurn *abi_route_issueSnitch *abi_route_getSnitched *abi_route_clawbackStake *abi_route_clawbackStakeToValidator *abi_route_upgradeToNewValidatorVersion *abi_route_flashloan *abi_route_claimLeftAlgo *abi_route_operatorExit *abi_route_goOnline *abi_route_goOffline *abi_route_getEligibilityFlag

	// this contract does not implement the given ABI method for call NoOp
	err

*call_CloseOut:
	pushbytes 0x785e526e // method "closeOutOfApplication(any[])void"
	txna ApplicationArgs 0
	match *abi_route_closeOutOfApplication

	// this contract does not implement the given ABI method for call CloseOut
	err