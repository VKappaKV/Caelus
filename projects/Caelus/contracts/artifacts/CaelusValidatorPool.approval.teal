#pragma version 11
intcblock 1 0 50000000000000 30000000000 2 1000
bytecblock 0x6d6178445374616b65 0x6f70657261746f72436f6d6d6974 0x6f70657261746f72 0x73617475726174696f6e427566666572 0x706572666f726d616e6365 0x63726561746f72 0x64656c6567617465645374616b65 0x6d696e5374616b65 0x

// This TEAL was generated by TEALScript v0.105.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64,address,uint64)void
*abi_route_createApplication:
	// contractVersion: uint64
	txna ApplicationArgs 3
	btoi

	// operatorAddress: address
	txna ApplicationArgs 2
	dup
	len
	pushint 32
	==

	// argument 1 (operatorAddress) for createApplication must be a address
	assert

	// creatingContract: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,address,uint64)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(creatingContract: AppID, operatorAddress: Address, contractVersion: uint64): void
//
// ******************
// Public Methods    *
// ******************
//
// createApplication method called at creation, initializes some globalKey values
// @param {AppID} creatingContract - ApplicationID for the creator contract (CaelusAdminContract)
// @param {Address} operatorAddress - Address of the node operator used to sign online/offline txns and participate in auctions
// @param {uint64} contractVersion - Approval Program version for the node contract, stored in the CaelusAdminContract
createApplication:
	proto 3 0

	// contracts\CaelusValidator.algo.ts:63
	// this.minCommit.value = MIN_ALGO_STAKE_FOR_REWARDS
	bytec 7 //  "minStake"
	intc 3 // 30000000000
	app_global_put

	// contracts\CaelusValidator.algo.ts:64
	// this.creatorContractAppID.value = creatingContract
	bytec 5 //  "creator"
	frame_dig -1 // creatingContract: AppID
	app_global_put

	// contracts\CaelusValidator.algo.ts:65
	// this.operatorAddress.value = operatorAddress
	bytec 2 //  "operator"
	frame_dig -2 // operatorAddress: Address
	app_global_put

	// contracts\CaelusValidator.algo.ts:66
	// this.validatorPoolContractVersion.value = contractVersion
	pushbytes 0x636f6e747261637456657273696f6e // "contractVersion"
	frame_dig -3 // contractVersion: uint64
	app_global_put

	// contracts\CaelusValidator.algo.ts:69
	// this.operatorCommit.value = 0
	bytec 1 //  "operatorCommit"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:70
	// this.delegatedStake.value = 0
	bytec 6 //  "delegatedStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:71
	// this.maxDelegatableStake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:74
	// this.saturationBUFFER.value = 0
	bytec 3 //  "saturationBuffer"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:75
	// this.performanceCounter.value = 0
	bytec 4 //  "performance"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:76
	// this.isDelinquent.value = false
	pushbytes 0x697344656c696e7175656e74 // "isDelinquent"
	intc 1 // 0
	pushbytes 0x00
	intc 1 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// addToOperatorCommit(pay)void
*abi_route_addToOperatorCommit:
	// commit: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (commit) for addToOperatorCommit must be a pay transaction
	assert

	// execute addToOperatorCommit(pay)void
	callsub addToOperatorCommit
	intc 0 // 1
	return

// addToOperatorCommit(commit: PayTxn): void
//
// Used by the node operator to add to his stake amount for the node
//
// @param {PayTxn} commit - node operator stake commitment
// @throws {Error} if the sender isn't the node operator, the receiver isn't the app address or if the total balance is above 30M Algo
addToOperatorCommit:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 8 // 0x

	// contracts\CaelusValidator.algo.ts:86
	// totalBalanceUpdated = this.operatorCommit.value + commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	frame_bury 0 // totalBalanceUpdated: uint64

	// contracts\CaelusValidator.algo.ts:87
	// assert(totalBalanceUpdated < MAX_ALGO_STAKE_PER_ACCOUNT, 'Contract max balance cannot be over 30M Algo')
	frame_dig 0 // totalBalanceUpdated: uint64
	intc 2 // 50000000000000
	<

	// Contract max balance cannot be over 30M Algo
	assert

	// contracts\CaelusValidator.algo.ts:89
	// verifyPayTxn(commit, {
	//       sender: this.operatorAddress.value,
	//       receiver: this.app.address,
	//       amount: commit.amount,
	//     })
	// verify sender
	frame_dig -1 // commit: PayTxn
	gtxns Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"commit","field":"sender","expected":"this.operatorAddress.value"}
	assert

	// verify receiver
	frame_dig -1 // commit: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"commit","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	==

	// transaction verification failed: {"txn":"commit","field":"amount","expected":"commit.amount"}
	assert

	// contracts\CaelusValidator.algo.ts:94
	// this.operatorCommit.value += commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	bytec 1 //  "operatorCommit"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:95
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// removeFromOperatorCommit(uint64)void
*abi_route_removeFromOperatorCommit:
	// claimRequest: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeFromOperatorCommit(uint64)void
	callsub removeFromOperatorCommit
	intc 0 // 1
	return

// removeFromOperatorCommit(claimRequest: uint64): void
//
// Used by the node operator to remove from his stake amount for the node
// @param {uint64} claimRequest - amount claimed by the node operator to be removed from the contract balance and subtracted from the operator_commit counter
// @throws {Error} if the sender isn't the node operator or if the total commit by the node operator goes below the min threshold for rewards eligibility
removeFromOperatorCommit:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:104
	// verifyAppCallTxn(this.txn, {
	//       sender: this.operatorAddress.value,
	//     })
	// verify sender
	txn Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.operatorAddress.value"}
	assert

	// contracts\CaelusValidator.algo.ts:108
	// assert(
	//       this.operatorCommit.value - claimRequest > MIN_ALGO_STAKE_FOR_REWARDS,
	//       'Node Operator can take his stake below 30k only if the node contract will be closed'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // claimRequest: uint64
	-
	intc 3 // 30000000000
	>

	// Node Operator can take his stake below 30k only if the node contract will be closed
	assert

	// contracts\CaelusValidator.algo.ts:112
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.operatorAddress.value,
	//       amount: claimRequest,
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:113
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts\CaelusValidator.algo.ts:114
	// receiver: this.operatorAddress.value
	bytec 2 //  "operator"
	app_global_get
	itxn_field Receiver

	// contracts\CaelusValidator.algo.ts:115
	// amount: claimRequest
	frame_dig -1 // claimRequest: uint64
	itxn_field Amount

	// contracts\CaelusValidator.algo.ts:116
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusValidator.algo.ts:118
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// performanceCheck()void
*abi_route_performanceCheck:
	// execute performanceCheck()void
	callsub performanceCheck
	intc 0 // 1
	return

// performanceCheck(): void
performanceCheck:
	proto 0 0
	retsub

// getToleratedBlockDelta()uint64
*abi_route_getToleratedBlockDelta:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getToleratedBlockDelta()uint64
	callsub getToleratedBlockDelta
	itob
	concat
	log
	intc 0 // 1
	return

// getToleratedBlockDelta(): uint64
getToleratedBlockDelta:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:127
	// return 0;
	intc 1 // 0
	retsub

// reportRewards()void
*abi_route_reportRewards:
	// execute reportRewards()void
	callsub reportRewards
	intc 0 // 1
	return

// reportRewards(): void
reportRewards:
	proto 0 0
	retsub

// bid()void
*abi_route_bid:
	// execute bid()void
	callsub bid
	intc 0 // 1
	return

// bid(): void
bid:
	proto 0 0
	retsub

// addStake()void
*abi_route_addStake:
	// execute addStake()void
	callsub addStake
	intc 0 // 1
	return

// addStake(): void
addStake:
	proto 0 0
	retsub

// snitchBurn()void
*abi_route_snitchBurn:
	// execute snitchBurn()void
	callsub snitchBurn
	intc 0 // 1
	return

// snitchBurn(): void
snitchBurn:
	proto 0 0
	retsub

// snitch()void
*abi_route_snitch:
	// execute snitch()void
	callsub snitch
	intc 0 // 1
	return

// snitch(): void
snitch:
	proto 0 0
	retsub

// getSnitched()void
*abi_route_getSnitched:
	// execute getSnitched()void
	callsub getSnitched
	intc 0 // 1
	return

// getSnitched(): void
getSnitched:
	proto 0 0
	retsub

// clawbackStake()void
*abi_route_clawbackStake:
	// execute clawbackStake()void
	callsub clawbackStake
	intc 0 // 1
	return

// clawbackStake(): void
clawbackStake:
	proto 0 0
	retsub

// clawbackStakeToValidator()void
*abi_route_clawbackStakeToValidator:
	// execute clawbackStakeToValidator()void
	callsub clawbackStakeToValidator
	intc 0 // 1
	return

// clawbackStakeToValidator(): void
clawbackStakeToValidator:
	proto 0 0
	retsub

// claimLeftAlgo()void
*abi_route_claimLeftAlgo:
	// execute claimLeftAlgo()void
	callsub claimLeftAlgo
	intc 0 // 1
	return

// claimLeftAlgo(): void
claimLeftAlgo:
	proto 0 0
	retsub

// checkAlgodVersion()void
*abi_route_checkAlgodVersion:
	// execute checkAlgodVersion()void
	callsub checkAlgodVersion
	intc 0 // 1
	return

// checkAlgodVersion(): void
checkAlgodVersion:
	proto 0 0
	retsub

// goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// votePK: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub goOnline
	intc 0 // 1
	return

// goOnline(feePayment: PayTxn, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// Used to set the Contract account online for consensus. Always check that account is online and incentivesEligible before having delegatable stake
//
// @param {PayTxn} feePayment - Payment transaction to the contract to cover costs for Eligibility fee; 0 for renewal.
// @param {bytes} votePK - The vote public key
// @param {bytes} selectionPK - The selection public key
// @param {bytes} stateProofPK - the state proof public key
// @param {uint64} voteFirst - Index of first valid block for the participation keys
// @param {uint64} voteLast - Index of last valid block for for the participation keys
// @param {uint64} voteKeyDilution - The vote key dilution value
// @throws {Error} if the caller isn't the node operator
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 8 // 0x

	// contracts\CaelusValidator.algo.ts:188
	// assert(
	//       this.txn.sender === this.operatorAddress.value,
	//       'Only the Node Operator can register online with participation key'
	//     )
	txn Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// Only the Node Operator can register online with participation key
	assert

	// contracts\CaelusValidator.algo.ts:194
	// assert(
	//       this.app.address.balance >= MIN_ALGO_STAKE_FOR_REWARDS,
	//       'Contract needs 30k Algo as minimum balance for rewards eligibility'
	//     )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 3 // 30000000000
	>=

	// Contract needs 30k Algo as minimum balance for rewards eligibility
	assert

	// contracts\CaelusValidator.algo.ts:200
	// assert(
	//       this.operatorCommit.value >= this.minCommit.value,
	//       'Operator commit must be higher than minimum balance for rewards eligibility'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	bytec 7 //  "minStake"
	app_global_get
	>=

	// Operator commit must be higher than minimum balance for rewards eligibility
	assert

	// contracts\CaelusValidator.algo.ts:205
	// extraFee = this.getGoOnlineFeeAmount()
	callsub getGoOnlineFeeAmount
	frame_bury 0 // extraFee: uint64

	// contracts\CaelusValidator.algo.ts:207
	// verifyPayTxn(feePayment, { receiver: this.app.address, amount: extraFee })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// contracts\CaelusValidator.algo.ts:209
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:210
	// votePK: votePK
	frame_dig -2 // votePK: bytes
	itxn_field VotePK

	// contracts\CaelusValidator.algo.ts:211
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: bytes
	itxn_field SelectionPK

	// contracts\CaelusValidator.algo.ts:212
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: bytes
	itxn_field StateProofPK

	// contracts\CaelusValidator.algo.ts:213
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\CaelusValidator.algo.ts:214
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\CaelusValidator.algo.ts:215
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\CaelusValidator.algo.ts:216
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOffline(uint64)void
*abi_route_goOffline:
	// offlineCase: uint64
	txna ApplicationArgs 1
	btoi

	// execute goOffline(uint64)void
	callsub goOffline
	intc 0 // 1
	return

// goOffline(offlineCase: uint64): void
//
// Set the contract account to offline so that it doesn't participate in consensus anymore.
// if graceful then it only means that there was some migration or other operation [CASE 1]
// if used to force the account offline because of bad behavior, then set up a flag for penalties [CASE 2]
//
// @param {uint64} offlineCase - {0}: graceful offline of the node by the node runner or the main Caelus contract
// {1}: node is misbehaving and needs to be set offline by the main Caelus contract
goOffline:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:229
	// assert(
	//       this.txn.sender === this.operatorAddress.value || this.txn.sender === this.creatorContractAppID.value.address,
	//       'Only Node Operator or Caelus Admin contract can set the contract offline'
	//     )
	txn Sender
	bytec 2 //  "operator"
	app_global_get
	==
	dup
	bnz *skip_or0
	txn Sender
	bytec 5 //  "creator"
	app_global_get
	app_params_get AppAddress
	pop
	==
	||

*skip_or0:
	// Only Node Operator or Caelus Admin contract can set the contract offline
	assert

	// *if0_condition
	// contracts\CaelusValidator.algo.ts:234
	// offlineCase === 0
	frame_dig -1 // offlineCase: uint64
	intc 1 // 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts\CaelusValidator.algo.ts:235
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if0_end:
	// *if1_condition
	// contracts\CaelusValidator.algo.ts:238
	// offlineCase === 1
	frame_dig -1 // offlineCase: uint64
	intc 0 // 1
	==
	bz *if1_end

	// *if1_consequent
	// contracts\CaelusValidator.algo.ts:243
	// verifyAppCallTxn(this.txn, {
	//         sender: this.creatorContractAppID.value.address,
	//       })
	// verify sender
	txn Sender
	bytec 5 //  "creator"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.creatorContractAppID.value.address"}
	assert

	// contracts\CaelusValidator.algo.ts:249
	// this.performanceCounter.value = 0
	bytec 4 //  "performance"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:250
	// this.maxDelegatableStake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:251
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// updateDelegationFactors(): void
updateDelegationFactors:
	proto 0 0

	// *if2_condition
	// contracts\CaelusValidator.algo.ts:258
	// this.operatorCommit.value > MIN_ALGO_STAKE_FOR_REWARDS
	bytec 1 //  "operatorCommit"
	app_global_get
	intc 3 // 30000000000
	>
	bz *if2_else

	// *if2_consequent
	// contracts\CaelusValidator.algo.ts:259
	// this.maxDelegatableStake.value = this.operatorCommit.value
	bytec 0 //  "maxDStake"
	bytec 1 //  "operatorCommit"
	app_global_get
	app_global_put
	b *if2_end

*if2_else:
	// contracts\CaelusValidator.algo.ts:261
	// this.maxDelegatableStake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

*if2_end:
	// contracts\CaelusValidator.algo.ts:265
	// this.maxDelegatableStake.value += PERFORMANCE_STAKE_INCREASE * (this.performanceCounter.value / 5)
	bytec 0 //  "maxDStake"
	app_global_get
	pushint 10000000000
	bytec 4 //  "performance"
	app_global_get
	pushint 5
	/
	*
	+
	bytec 0 //  "maxDStake"
	swap
	app_global_put

	// *if3_condition
	// contracts\CaelusValidator.algo.ts:268
	// this.app.address.balance > MAX_ALGO_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 2 // 50000000000000
	>
	bz *if3_elseif1_condition

	// *if3_consequent
	// contracts\CaelusValidator.algo.ts:269
	// this.maxDelegatableStake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put
	b *if3_end

*if3_elseif1_condition:
	// contracts\CaelusValidator.algo.ts:270
	// this.app.address.balance + this.maxDelegatableStake.value > MAX_ALGO_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 0 //  "maxDStake"
	app_global_get
	+
	intc 2 // 50000000000000
	>
	bz *if3_end

	// *if3_elseif1_consequent
	// contracts\CaelusValidator.algo.ts:271
	// this.maxDelegatableStake.value =
	//         this.app.address.balance + this.maxDelegatableStake.value - MAX_ALGO_STAKE_PER_ACCOUNT
	bytec 0 //  "maxDStake"
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 0 //  "maxDStake"
	app_global_get
	+
	intc 2 // 50000000000000
	-
	app_global_put

*if3_end:
	// *if4_condition
	// contracts\CaelusValidator.algo.ts:276
	// this.maxDelegatableStake.value > 0
	bytec 0 //  "maxDStake"
	app_global_get
	intc 1 // 0
	>
	bz *if4_else

	// *if4_consequent
	// contracts\CaelusValidator.algo.ts:277
	// this.saturationBUFFER.value = (this.delegatedStake.value * 1000) / this.maxDelegatableStake.value
	bytec 3 //  "saturationBuffer"
	bytec 6 //  "delegatedStake"
	app_global_get
	intc 5 // 1000
	*
	bytec 0 //  "maxDStake"
	app_global_get
	/
	app_global_put
	b *if4_end

*if4_else:
	// contracts\CaelusValidator.algo.ts:279
	// this.saturationBUFFER.value = 1000
	bytec 3 //  "saturationBuffer"
	intc 5 // 1000
	app_global_put

*if4_end:
	retsub

// getGoOnlineFeeAmount(): uint64
//
// *****************
// Private Methods  *
// *****************
getGoOnlineFeeAmount:
	proto 0 1

	// *if5_condition
	// contracts\CaelusValidator.algo.ts:289
	// !this.getEligibilityFlag()
	callsub getEligibilityFlag
	!
	bz *if5_end

	// *if5_consequent
	// contracts\CaelusValidator.algo.ts:290
	// return globals.payoutsGoOnlineFee;
	global PayoutsGoOnlineFee
	retsub

*if5_end:
	// contracts\CaelusValidator.algo.ts:292
	// return 0;
	intc 1 // 0
	retsub

// getEligibilityFlag(): boolean
getEligibilityFlag:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:296
	// return this.app.address.incentiveEligible;
	global CurrentApplicationAddress
	acct_params_get AcctIncentiveEligible
	pop
	retsub

*create_NoOp:
	pushbytes 0x12f90c73 // method "createApplication(uint64,address,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xdfa20764 // method "addToOperatorCommit(pay)void"
	pushbytes 0xf6786084 // method "removeFromOperatorCommit(uint64)void"
	pushbytes 0x7cffc787 // method "performanceCheck()void"
	pushbytes 0x4be28675 // method "getToleratedBlockDelta()uint64"
	pushbytes 0x035b6a13 // method "reportRewards()void"
	pushbytes 0xe08ef21e // method "bid()void"
	pushbytes 0x6ce5dd5f // method "addStake()void"
	pushbytes 0xfa3707b2 // method "snitchBurn()void"
	pushbytes 0xfd046173 // method "snitch()void"
	pushbytes 0x94fad843 // method "getSnitched()void"
	pushbytes 0x54d05381 // method "clawbackStake()void"
	pushbytes 0xed0f417f // method "clawbackStakeToValidator()void"
	pushbytes 0xa69ea4a7 // method "claimLeftAlgo()void"
	pushbytes 0x199e298d // method "checkAlgodVersion()void"
	pushbytes 0x400e14fb // method "goOnline(pay,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0xa8c47e78 // method "goOffline(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_addToOperatorCommit *abi_route_removeFromOperatorCommit *abi_route_performanceCheck *abi_route_getToleratedBlockDelta *abi_route_reportRewards *abi_route_bid *abi_route_addStake *abi_route_snitchBurn *abi_route_snitch *abi_route_getSnitched *abi_route_clawbackStake *abi_route_clawbackStakeToValidator *abi_route_claimLeftAlgo *abi_route_checkAlgodVersion *abi_route_goOnline *abi_route_goOffline

	// this contract does not implement the given ABI method for call NoOp
	err