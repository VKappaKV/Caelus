#pragma version 11
intcblock 1 0 50000000000000 30000000000 2 1000 6
bytecblock 0x6d6178445374616b65 0x6f70657261746f72436f6d6d6974 0x6f70657261746f72 0x 0x73617475726174696f6e427566666572 0x706572666f726d616e6365 0x64656c6567617465645374616b65 0x6d696e5374616b65 0x63726561746f72

// This TEAL was generated by TEALScript v0.105.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 6 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(application,address,uint64)void
*abi_route_createApplication:
	// contractVersion: uint64
	txna ApplicationArgs 3
	btoi

	// operatorAddress: address
	txna ApplicationArgs 2
	dup
	len
	pushint 32
	==

	// argument 1 (operatorAddress) for createApplication must be a address
	assert

	// creatingContract: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute createApplication(application,address,uint64)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(creatingContract: AppReference, operatorAddress: Address, contractVersion: uint64): void
//
// ******************
// Public Methods    *
// ******************
//
// createApplication method called at creation, initializes some globalKey values
// @param {AppReference} creatingContract - ApplicationID for the creator contract (CaelusAdminContract)
// @param {Address} operatorAddress - Address of the node operator used to sign online/offline txns and participate in auctions
// @param {uint64} contractVersion - Approval Program version for the node contract, stored in the CaelusAdminContract
createApplication:
	proto 3 0

	// contracts\CaelusValidator.algo.ts:61
	// this.min_Commit.value = MIN_ALGO_STAKE_FOR_REWARDS
	bytec 7 //  "minStake"
	intc 3 // 30000000000
	app_global_put

	// contracts\CaelusValidator.algo.ts:62
	// this.creatorContract_AppReference.value = creatingContract
	bytec 8 //  "creator"
	frame_dig -1 // creatingContract: AppReference
	app_global_put

	// contracts\CaelusValidator.algo.ts:63
	// this.operator_Address.value = operatorAddress
	bytec 2 //  "operator"
	frame_dig -2 // operatorAddress: Address
	app_global_put

	// contracts\CaelusValidator.algo.ts:64
	// this.validatorPoolContract_version.value = contractVersion
	pushbytes 0x636f6e747261637456657273696f6e // "contractVersion"
	frame_dig -3 // contractVersion: uint64
	app_global_put

	// contracts\CaelusValidator.algo.ts:67
	// this.operator_Commit.value = 0
	bytec 1 //  "operatorCommit"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:68
	// this.delegated_stake.value = 0
	bytec 6 //  "delegatedStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:69
	// this.max_delegatable_stake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:72
	// this.saturation_BUFFER.value = 0
	bytec 4 //  "saturationBuffer"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:73
	// this.performance_counter.value = 0
	bytec 5 //  "performance"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:74
	// this.isDelinquent.value = false
	pushbytes 0x697344656c696e7175656e74 // "isDelinquent"
	intc 1 // 0
	pushbytes 0x00
	intc 1 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// addToOperatorCommit(pay)void
*abi_route_addToOperatorCommit:
	// commit: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (commit) for addToOperatorCommit must be a pay transaction
	assert

	// execute addToOperatorCommit(pay)void
	callsub addToOperatorCommit
	intc 0 // 1
	return

// addToOperatorCommit(commit: PayTxn): void
//
// Used by the node operator to add to his stake amount for the node
//
// @param {PayTxn} commit - node operator stake commitment
// @throws {Error} if the sender isn't the node operator, the receiver isn't the app address or if the total balance is above 30M Algo
addToOperatorCommit:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 3 // 0x

	// contracts\CaelusValidator.algo.ts:84
	// totalBalanceUpdated = this.operator_Commit.value + commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	frame_bury 0 // totalBalanceUpdated: uint64

	// contracts\CaelusValidator.algo.ts:85
	// assert(totalBalanceUpdated < MAX_ALGO_STAKE_PER_ACCOUNT, 'Contract max balance cannot be over 30M Algo')
	frame_dig 0 // totalBalanceUpdated: uint64
	intc 2 // 50000000000000
	<

	// Contract max balance cannot be over 30M Algo
	assert

	// contracts\CaelusValidator.algo.ts:87
	// verifyPayTxn(commit, {
	//       sender: this.operator_Address.value,
	//       receiver: this.app.address,
	//       amount: commit.amount,
	//     })
	// verify sender
	frame_dig -1 // commit: PayTxn
	gtxns Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"commit","field":"sender","expected":"this.operator_Address.value"}
	assert

	// verify receiver
	frame_dig -1 // commit: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"commit","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	==

	// transaction verification failed: {"txn":"commit","field":"amount","expected":"commit.amount"}
	assert

	// contracts\CaelusValidator.algo.ts:92
	// this.operator_Commit.value += commit.amount
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // commit: PayTxn
	gtxns Amount
	+
	bytec 1 //  "operatorCommit"
	swap
	app_global_put

	// contracts\CaelusValidator.algo.ts:93
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// removeFromOperatorCommit(uint64)void
*abi_route_removeFromOperatorCommit:
	// claimRequest: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeFromOperatorCommit(uint64)void
	callsub removeFromOperatorCommit
	intc 0 // 1
	return

// removeFromOperatorCommit(claimRequest: uint64): void
//
// Used by the node operator to remove from his stake amount for the node
// @param {uint64} claimRequest - amount claimed by the node operator to be removed from the contract balance and subtracted from the operator_commit counter
// @throws {Error} if the sender isn't the node operator or if the total commit by the node operator goes below the min threshold for rewards eligibility
removeFromOperatorCommit:
	proto 1 0

	// contracts\CaelusValidator.algo.ts:102
	// verifyAppCallTxn(this.txn, {
	//       sender: this.operator_Address.value,
	//     })
	// verify sender
	txn Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.operator_Address.value"}
	assert

	// contracts\CaelusValidator.algo.ts:106
	// assert(
	//       this.operator_Commit.value - claimRequest > MIN_ALGO_STAKE_FOR_REWARDS,
	//       'Node Operator can take his stake below 30k only if the node contract will be closed'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	frame_dig -1 // claimRequest: uint64
	-
	intc 3 // 30000000000
	>

	// Node Operator can take his stake below 30k only if the node contract will be closed
	assert

	// contracts\CaelusValidator.algo.ts:110
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.operator_Address.value,
	//       amount: claimRequest,
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:111
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts\CaelusValidator.algo.ts:112
	// receiver: this.operator_Address.value
	bytec 2 //  "operator"
	app_global_get
	itxn_field Receiver

	// contracts\CaelusValidator.algo.ts:113
	// amount: claimRequest
	frame_dig -1 // claimRequest: uint64
	itxn_field Amount

	// contracts\CaelusValidator.algo.ts:114
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CaelusValidator.algo.ts:116
	// this.updateDelegationFactors()
	callsub updateDelegationFactors
	retsub

// performanceCheck()void
*abi_route_performanceCheck:
	// execute performanceCheck()void
	callsub performanceCheck
	intc 0 // 1
	return

// performanceCheck(): void
performanceCheck:
	proto 0 0
	retsub

// getToleratedBlockDelta()uint64
*abi_route_getToleratedBlockDelta:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getToleratedBlockDelta()uint64
	callsub getToleratedBlockDelta
	itob
	concat
	log
	intc 0 // 1
	return

// getToleratedBlockDelta(): uint64
getToleratedBlockDelta:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:123
	// return 0;
	intc 1 // 0
	retsub

// reportRewards(uint64)void
*abi_route_reportRewards:
	// block: uint64
	txna ApplicationArgs 1
	btoi

	// execute reportRewards(uint64)void
	callsub reportRewards
	intc 0 // 1
	return

// reportRewards(block: uint64): void
reportRewards:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 3 // 0x
	dup

	// contracts\CaelusValidator.algo.ts:130
	// report = blocks[block].proposerPayout
	frame_dig -1 // block: uint64
	block BlkProposerPayout
	frame_bury 0 // report: uint64

	// contracts\CaelusValidator.algo.ts:131
	// takeFee = (report * 6) / 100
	frame_dig 0 // report: uint64
	intc 6 // 6
	*
	pushint 100
	/
	frame_bury 1 // takeFee: uint64
	retsub

// bid()void
*abi_route_bid:
	// execute bid()void
	callsub bid
	intc 0 // 1
	return

// bid(): void
bid:
	proto 0 0
	retsub

// add_stake()void
*abi_route_add_stake:
	// execute add_stake()void
	callsub add_stake
	intc 0 // 1
	return

// add_stake(): void
add_stake:
	proto 0 0
	retsub

// snitch_burn()void
*abi_route_snitch_burn:
	// execute snitch_burn()void
	callsub snitch_burn
	intc 0 // 1
	return

// snitch_burn(): void
snitch_burn:
	proto 0 0
	retsub

// snitch()void
*abi_route_snitch:
	// execute snitch()void
	callsub snitch
	intc 0 // 1
	return

// snitch(): void
snitch:
	proto 0 0
	retsub

// get_snitched()void
*abi_route_get_snitched:
	// execute get_snitched()void
	callsub get_snitched
	intc 0 // 1
	return

// get_snitched(): void
get_snitched:
	proto 0 0
	retsub

// clawback_stake()void
*abi_route_clawback_stake:
	// execute clawback_stake()void
	callsub clawback_stake
	intc 0 // 1
	return

// clawback_stake(): void
clawback_stake:
	proto 0 0
	retsub

// clawback_stake_to_validator()void
*abi_route_clawback_stake_to_validator:
	// execute clawback_stake_to_validator()void
	callsub clawback_stake_to_validator
	intc 0 // 1
	return

// clawback_stake_to_validator(): void
clawback_stake_to_validator:
	proto 0 0
	retsub

// claimLeftAlgo()void
*abi_route_claimLeftAlgo:
	// execute claimLeftAlgo()void
	callsub claimLeftAlgo
	intc 0 // 1
	return

// claimLeftAlgo(): void
claimLeftAlgo:
	proto 0 0
	retsub

// checkAlgodVersion()void
*abi_route_checkAlgodVersion:
	// execute checkAlgodVersion()void
	callsub checkAlgodVersion
	intc 0 // 1
	return

// checkAlgodVersion(): void
checkAlgodVersion:
	proto 0 0
	retsub

// goOnline(pay,string,string,string,uint64,uint64,uint64)void
*abi_route_goOnline:
	// voteKeyDilution: uint64
	txna ApplicationArgs 6
	btoi

	// voteLast: uint64
	txna ApplicationArgs 5
	btoi

	// voteFirst: uint64
	txna ApplicationArgs 4
	btoi

	// stateProofPK: string
	txna ApplicationArgs 3
	extract 2 0

	// selectionPK: string
	txna ApplicationArgs 2
	extract 2 0

	// votePK: string
	txna ApplicationArgs 1
	extract 2 0

	// feePayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 6 (feePayment) for goOnline must be a pay transaction
	assert

	// execute goOnline(pay,string,string,string,uint64,uint64,uint64)void
	callsub goOnline
	intc 0 // 1
	return

// goOnline(feePayment: PayTxn, votePK: string, selectionPK: string, stateProofPK: string, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64): void
//
// Used to set the Contract account online for consensus. Always check that account is online and incentivesEligible before having delegatable stake
//
// @param {PayTxn} feePayment - Payment transaction to the contract to cover costs for Eligibility fee; 0 for renewal.
// @param {string} votePK - The vote public key
// @param {string} selectionPK - The selection public key
// @param {string} stateProofPK - the state proof public key
// @param {uint64} voteFirst - Index of first valid block for the participation keys
// @param {uint64} voteLast - Index of last valid block for for the participation keys
// @param {uint64} voteKeyDilution - The vote key dilution value
// @throws {Error} if the caller isn't the node operator
goOnline:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 3 // 0x

	// contracts\CaelusValidator.algo.ts:178
	// verifyAppCallTxn(this.txn, {
	//       sender: this.operator_Address.value,
	//     })
	// verify sender
	txn Sender
	bytec 2 //  "operator"
	app_global_get
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.operator_Address.value"}
	assert

	// contracts\CaelusValidator.algo.ts:183
	// assert(
	//       this.app.address.balance >= MIN_ALGO_STAKE_FOR_REWARDS,
	//       'Contract needs 30k Algo as minimum balance for rewards eligibility'
	//     )
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 3 // 30000000000
	>=

	// Contract needs 30k Algo as minimum balance for rewards eligibility
	assert

	// contracts\CaelusValidator.algo.ts:189
	// assert(
	//       this.operator_Commit.value >= this.min_Commit.value,
	//       'Operator commit must be higher than minimum balance for rewards eligibility'
	//     )
	bytec 1 //  "operatorCommit"
	app_global_get
	bytec 7 //  "minStake"
	app_global_get
	>=

	// Operator commit must be higher than minimum balance for rewards eligibility
	assert

	// contracts\CaelusValidator.algo.ts:194
	// extraFee = this.getGoOnlineFeeAmount()
	callsub getGoOnlineFeeAmount
	frame_bury 0 // extraFee: uint64

	// contracts\CaelusValidator.algo.ts:196
	// verifyPayTxn(feePayment, { receiver: this.app.address, amount: extraFee })
	// verify receiver
	frame_dig -1 // feePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // extraFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"extraFee"}
	assert

	// contracts\CaelusValidator.algo.ts:198
	// sendOnlineKeyRegistration({
	//       votePK: votePK,
	//       selectionPK: selectionPK,
	//       stateProofPK: stateProofPK,
	//       voteFirst: voteFirst,
	//       voteLast: voteLast,
	//       voteKeyDilution: voteKeyDilution,
	//       fee: extraFee,
	//     })
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// contracts\CaelusValidator.algo.ts:199
	// votePK: votePK
	frame_dig -2 // votePK: string
	itxn_field VotePK

	// contracts\CaelusValidator.algo.ts:200
	// selectionPK: selectionPK
	frame_dig -3 // selectionPK: string
	itxn_field SelectionPK

	// contracts\CaelusValidator.algo.ts:201
	// stateProofPK: stateProofPK
	frame_dig -4 // stateProofPK: string
	itxn_field StateProofPK

	// contracts\CaelusValidator.algo.ts:202
	// voteFirst: voteFirst
	frame_dig -5 // voteFirst: uint64
	itxn_field VoteFirst

	// contracts\CaelusValidator.algo.ts:203
	// voteLast: voteLast
	frame_dig -6 // voteLast: uint64
	itxn_field VoteLast

	// contracts\CaelusValidator.algo.ts:204
	// voteKeyDilution: voteKeyDilution
	frame_dig -7 // voteKeyDilution: uint64
	itxn_field VoteKeyDilution

	// contracts\CaelusValidator.algo.ts:205
	// fee: extraFee
	frame_dig 0 // extraFee: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// goOffline(uint64)void
*abi_route_goOffline:
	// offlineCase: uint64
	txna ApplicationArgs 1
	btoi

	// execute goOffline(uint64)void
	callsub goOffline
	intc 0 // 1
	return

// goOffline(offlineCase: uint64): void
//
// Set the contract account to offline so that it doesn't participate in consensus anymore.
// if graceful then it only means that there was some migration or other operation [CASE 1]
// if used to force the account offline because of bad behavior, then set up a flag for penalties [CASE 2]
//
// @param {uint64} offlineCase - {0}: graceful offline of the node by the node runner or the main Caelus contract
// {1}: node is misbehaving and needs to be set offline by the main Caelus contract
goOffline:
	proto 1 0

	// *if0_condition
	// contracts\CaelusValidator.algo.ts:227
	// offlineCase === 0
	frame_dig -1 // offlineCase: uint64
	intc 1 // 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts\CaelusValidator.algo.ts:228
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if0_end:
	// *if1_condition
	// contracts\CaelusValidator.algo.ts:231
	// offlineCase === 1
	frame_dig -1 // offlineCase: uint64
	intc 0 // 1
	==
	bz *if1_end

	// *if1_consequent
	// contracts\CaelusValidator.algo.ts:236
	// verifyAppCallTxn(this.txn, {
	//         sender: this.creatorContract_AppReference.value.address,
	//       })
	// verify sender
	txn Sender
	bytec 8 //  "creator"
	app_global_get
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"this.creatorContract_AppReference.value.address"}
	assert

	// contracts\CaelusValidator.algo.ts:242
	// this.performance_counter.value = 0
	bytec 5 //  "performance"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:243
	// this.max_delegatable_stake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

	// contracts\CaelusValidator.algo.ts:244
	// sendOfflineKeyRegistration({})
	itxn_begin
	intc 4 //  keyreg
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if1_end:
	retsub

// updateDelegationFactors(): void
updateDelegationFactors:
	proto 0 0

	// *if2_condition
	// contracts\CaelusValidator.algo.ts:251
	// this.operator_Commit.value > MIN_ALGO_STAKE_FOR_REWARDS
	bytec 1 //  "operatorCommit"
	app_global_get
	intc 3 // 30000000000
	>
	bz *if2_else

	// *if2_consequent
	// contracts\CaelusValidator.algo.ts:252
	// this.max_delegatable_stake.value = this.operator_Commit.value
	bytec 0 //  "maxDStake"
	bytec 1 //  "operatorCommit"
	app_global_get
	app_global_put
	b *if2_end

*if2_else:
	// contracts\CaelusValidator.algo.ts:254
	// this.max_delegatable_stake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put

*if2_end:
	// contracts\CaelusValidator.algo.ts:258
	// this.max_delegatable_stake.value += PERFORMANCE_STAKE_INCREASE * (this.performance_counter.value / 5)
	bytec 0 //  "maxDStake"
	app_global_get
	pushint 10000000000
	bytec 5 //  "performance"
	app_global_get
	pushint 5
	/
	*
	+
	bytec 0 //  "maxDStake"
	swap
	app_global_put

	// *if3_condition
	// contracts\CaelusValidator.algo.ts:261
	// this.app.address.balance > MAX_ALGO_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	intc 2 // 50000000000000
	>
	bz *if3_elseif1_condition

	// *if3_consequent
	// contracts\CaelusValidator.algo.ts:262
	// this.max_delegatable_stake.value = 0
	bytec 0 //  "maxDStake"
	intc 1 // 0
	app_global_put
	b *if3_end

*if3_elseif1_condition:
	// contracts\CaelusValidator.algo.ts:263
	// this.app.address.balance + this.max_delegatable_stake.value > MAX_ALGO_STAKE_PER_ACCOUNT
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 0 //  "maxDStake"
	app_global_get
	+
	intc 2 // 50000000000000
	>
	bz *if3_end

	// *if3_elseif1_consequent
	// contracts\CaelusValidator.algo.ts:264
	// this.max_delegatable_stake.value =
	//         this.app.address.balance + this.max_delegatable_stake.value - MAX_ALGO_STAKE_PER_ACCOUNT
	bytec 0 //  "maxDStake"
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	bytec 0 //  "maxDStake"
	app_global_get
	+
	intc 2 // 50000000000000
	-
	app_global_put

*if3_end:
	// *if4_condition
	// contracts\CaelusValidator.algo.ts:269
	// this.max_delegatable_stake.value > 0
	bytec 0 //  "maxDStake"
	app_global_get
	intc 1 // 0
	>
	bz *if4_else

	// *if4_consequent
	// contracts\CaelusValidator.algo.ts:270
	// this.saturation_BUFFER.value = (this.delegated_stake.value * 1000) / this.max_delegatable_stake.value
	bytec 4 //  "saturationBuffer"
	bytec 6 //  "delegatedStake"
	app_global_get
	intc 5 // 1000
	*
	bytec 0 //  "maxDStake"
	app_global_get
	/
	app_global_put
	b *if4_end

*if4_else:
	// contracts\CaelusValidator.algo.ts:272
	// this.saturation_BUFFER.value = 1000
	bytec 4 //  "saturationBuffer"
	intc 5 // 1000
	app_global_put

*if4_end:
	retsub

// getGoOnlineFeeAmount(): uint64
//
// *****************
// Private Methods  *
// *****************
getGoOnlineFeeAmount:
	proto 0 1

	// *if5_condition
	// contracts\CaelusValidator.algo.ts:282
	// !this.getEligibilityFlag()
	callsub getEligibilityFlag
	!
	bz *if5_end

	// *if5_consequent
	// contracts\CaelusValidator.algo.ts:283
	// return globals.payoutsGoOnlineFee;
	global PayoutsGoOnlineFee
	retsub

*if5_end:
	// contracts\CaelusValidator.algo.ts:285
	// return 0;
	intc 1 // 0
	retsub

// getEligibilityFlag(): boolean
getEligibilityFlag:
	proto 0 1

	// contracts\CaelusValidator.algo.ts:289
	// return this.app.address.incentiveEligible;
	global CurrentApplicationAddress
	acct_params_get AcctIncentiveEligible
	pop
	retsub

*create_NoOp:
	pushbytes 0x8430ba8b // method "createApplication(application,address,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xdfa20764 // method "addToOperatorCommit(pay)void"
	pushbytes 0xf6786084 // method "removeFromOperatorCommit(uint64)void"
	pushbytes 0x7cffc787 // method "performanceCheck()void"
	pushbytes 0x4be28675 // method "getToleratedBlockDelta()uint64"
	pushbytes 0x44a5b576 // method "reportRewards(uint64)void"
	pushbytes 0xe08ef21e // method "bid()void"
	pushbytes 0x7e32f7a8 // method "add_stake()void"
	pushbytes 0x5ffd056f // method "snitch_burn()void"
	pushbytes 0xfd046173 // method "snitch()void"
	pushbytes 0xf9417623 // method "get_snitched()void"
	pushbytes 0xdf471fd6 // method "clawback_stake()void"
	pushbytes 0x4d69e1cb // method "clawback_stake_to_validator()void"
	pushbytes 0xa69ea4a7 // method "claimLeftAlgo()void"
	pushbytes 0x199e298d // method "checkAlgodVersion()void"
	pushbytes 0xb7419827 // method "goOnline(pay,string,string,string,uint64,uint64,uint64)void"
	pushbytes 0xa8c47e78 // method "goOffline(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_addToOperatorCommit *abi_route_removeFromOperatorCommit *abi_route_performanceCheck *abi_route_getToleratedBlockDelta *abi_route_reportRewards *abi_route_bid *abi_route_add_stake *abi_route_snitch_burn *abi_route_snitch *abi_route_get_snitched *abi_route_clawback_stake *abi_route_clawback_stake_to_validator *abi_route_claimLeftAlgo *abi_route_checkAlgodVersion *abi_route_goOnline *abi_route_goOffline

	// this contract does not implement the given ABI method for call NoOp
	err